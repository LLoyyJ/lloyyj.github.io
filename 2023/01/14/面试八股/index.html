<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试八股 | LLoyyj's blog</title><meta name="keywords" content="java,八股,面试"><meta name="author" content="LLoyyj"><meta name="copyright" content="LLoyyj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础Java语言的特点【2】 简单易学 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络">
<meta property="og:type" content="article">
<meta property="og:title" content="面试八股">
<meta property="og:url" content="http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="LLoyyj&#39;s blog">
<meta property="og:description" content="Java基础Java语言的特点【2】 简单易学 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg">
<meta property="article:published_time" content="2023-01-14T07:27:59.000Z">
<meta property="article:modified_time" content="2023-05-21T08:26:48.423Z">
<meta property="article:author" content="LLoyyj">
<meta property="article:tag" content="java">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/01/11/x4cowVP16vkygHB.png"><link rel="canonical" href="http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#5F9EA0&quot;,&quot;paginator&quot;:&quot;#B0E0E6&quot;,&quot;button_hover&quot;:&quot;#DED3CD&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;,&quot;scrollbar_color&quot;:&quot;#49b1f5&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: LLoyyj","link":"Link: ","source":"Source: LLoyyj's blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-05-21 16:26:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://s2.loli.net/2023/01/11/1NsbGvmfukWXBQM.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LLoyyj's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-14T07:27:59.000Z" title="Created 2023-01-14 15:27:59">2023-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-21T08:26:48.423Z" title="Updated 2023-05-21 16:26:48">2023-05-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>44min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h3 id="Java语言的特点【2】"><a href="#Java语言的特点【2】" class="headerlink" title="Java语言的特点【2】"></a>Java语言的特点【2】</h3><ul>
<li>简单易学</li>
<li><strong>面向对象</strong>（封装，继承，多态）；</li>
<li><strong>平台无关性</strong>（ Java 虚拟机实现平台无关性）；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li><strong>编译与解释并存</strong></li>
</ul>
<h3 id="比较-JVM-和-JDK-以及-JRE【2】"><a href="#比较-JVM-和-JDK-以及-JRE【2】" class="headerlink" title="比较 JVM 和 JDK 以及 JRE【2】"></a>比较 JVM 和 JDK 以及 JRE【2】</h3><ul>
<li>JVM：运行字节码文件（.class文件）</li>
<li>JRE：运行已编译Java程序 （包括JVM）</li>
<li>JDK：Java开发使用，也可编译执行 （包括JRE）</li>
</ul>
<h3 id="为什么说-Java-语言“解释与编译并存”【2】"><a href="#为什么说-Java-语言“解释与编译并存”【2】" class="headerlink" title="为什么说 Java 语言“解释与编译并存”【2】"></a>为什么说 Java 语言“解释与编译并存”【2】</h3><p>​	这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。</p>
<p>​	.java文件由<strong>编译器</strong>编译成字节码文件（.class文件），再由<strong>解释器</strong>解释为机器码执行。</p>
<h3 id="Java-基本类型有哪几种，各占多少位？【2】"><a href="#Java-基本类型有哪几种，各占多少位？【2】" class="headerlink" title="Java 基本类型有哪几种，各占多少位？【2】"></a>Java 基本类型有哪几种，各占多少位？【2】</h3><blockquote>
<p>除了八种基本数据类型以外都是引用类型</p>
</blockquote>
<ul>
<li>六种数字类型<ul>
<li>四种整数型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code></li>
<li>两种浮点型：<code>float</code>，<code>double</code></li>
</ul>
</li>
<li>一种字符类型：<code>char</code></li>
<li>一种布尔型：<code>boolean</code></li>
</ul>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>位数</th>
<th>字节</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>8</td>
<td>1</td>
<td>0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td><code>short</code></td>
<td>16</td>
<td>2</td>
<td>0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td><code>int</code></td>
<td>32</td>
<td>4</td>
<td>0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td><code>long</code></td>
<td>64</td>
<td>8</td>
<td>0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td><code>char</code></td>
<td>16</td>
<td>2</td>
<td>‘u0000’</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td><code>float</code></td>
<td>32</td>
<td>4</td>
<td>0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td><code>double</code></td>
<td>64</td>
<td>8</td>
<td>0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>1</td>
<td></td>
<td>false</td>
<td>true、false</td>
</tr>
</tbody></table>
<blockquote>
<p>每种基本类型所占的存储空间不变——Java程序相较于其他大多数语言编写的程序更具可移植性的原因之一</p>
</blockquote>
<ol>
<li>Java中使用<code>long</code>类型的数据一定要加上L，否则作为整型解析</li>
<li>char使用单引号，String使用双引号</li>
<li>八种基本数据类型对应的包装类是<code>Byte</code>，<code>Short</code>，<code>Integer</code>，<code>Long</code> ,  <code>Float</code>，<code>Double</code> , <code>Character</code> , <code>Boolean</code></li>
</ol>
<h4 id="基本数据类型-vs-包装类型"><a href="#基本数据类型-vs-包装类型" class="headerlink" title="基本数据类型 vs 包装类型"></a>基本数据类型 vs 包装类型</h4><ul>
<li>基本类型<ul>
<li>成员变量<strong>有默认值</strong></li>
<li>不可用于泛型</li>
<li>局部变量存放于虚拟机<strong>栈</strong>中的局部变量表，未用<code>static</code>修饰的成员变量存放于虚拟机的<strong>堆</strong>中</li>
<li>相较于包装类型，占用空间非常小</li>
</ul>
</li>
<li>包装类型<ul>
<li>成员变量<strong>未赋值时无默认值</strong>，为<code>null</code></li>
<li>可用于泛型</li>
<li>属于对象类型，几乎所有的对象实例存放于<strong>堆</strong>中</li>
</ul>
</li>
</ul>
<h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><blockquote>
<p>Java基本数据类型的包装类型大部分都用到了缓存机制来提升性能</p>
</blockquote>
<ul>
<li><code>Byte</code> , <code>Short</code> , <code>Integer</code> , <code>Long</code> 这 4 种包装类默认创建了数值 <strong>[ -128</strong>，<strong>127]</strong> 的相应类型的缓存数据， <code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据， <code>Boolean</code> 直接返回 <code>True</code> or <code>False</code></li>
<li>如果超过了缓存范围仍会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡</li>
<li>当我们给定的整数在[-128,127]之间的话，那么会直接从cache中返回对应的Integer类的引用（或者说地址），如果整数的大小不在这个范围内的话，那么valueof()方法会新new一个Integer类型的对象，并返回</li>
<li>例：<code>Integer</code>使用 <code>Integer.valueOf()</code> 缓存</li>
</ul>
<h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><ul>
<li><p><strong>装箱：</strong>将基本数据类型用引用类型包装起来（例：<code>Integer.valueOf()</code> ）</p>
</li>
<li><p><strong>拆箱：</strong>将包装类型转换为基本数据类型（例：<code>Integer.intValue()</code> ）</p>
<blockquote>
<p>频繁拆装箱会严重影响系统的性能，应尽量避免不必要的拆装箱操作</p>
</blockquote>
</li>
</ul>
<h4 id="浮点数精度丢失问题"><a href="#浮点数精度丢失问题" class="headerlink" title="浮点数精度丢失问题"></a>浮点数精度丢失问题</h4><ul>
<li>由于计算机是二进制的且宽度有限，浮点数在计算机上无法精确表示</li>
<li>十进制的浮点数转换为二进制<ul>
<li>对浮点数不断*2直到不存在小数为止，得到的整数部分</li>
</ul>
</li>
<li><code>BigDecimal</code>用于大部分需要浮点数精确运算结果的业务场景</li>
</ul>
<h4 id="超过long整型的数据如何表示"><a href="#超过long整型的数据如何表示" class="headerlink" title="超过long整型的数据如何表示"></a>超过long整型的数据如何表示</h4><ul>
<li>超过基本数据类型的表达范围就会有数值溢出的风险（Long—64位）</li>
<li><code>BigInteger</code>用于表示超过<code>long</code>长整型数值范围的数据<ul>
<li>内部使用<code>int[]</code>数组存储任意大小的整型数据</li>
<li>相较于常规整数类型运算，<strong>运算效率相对较低</strong></li>
</ul>
</li>
</ul>
<h3 id="成员变量与局部变量的区别。【3】"><a href="#成员变量与局部变量的区别。【3】" class="headerlink" title="成员变量与局部变量的区别。【3】"></a>成员变量与局部变量的区别。【3】</h3><ul>
<li><p>语法形式</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">访问控制符</th>
<th align="center">static</th>
<th align="center">final</th>
</tr>
</thead>
<tbody><tr>
<td align="center">成员变量</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
<li><p>存储方式</p>
<ul>
<li>成员变量使用static修饰时：属于类</li>
<li>成员变量不使用static修饰时：属于实例</li>
<li>对象存储在堆内存</li>
<li>局部变量存储在栈内存</li>
</ul>
</li>
<li><p>生存时间</p>
<ul>
<li>成员变量：随对象创建而存在</li>
<li>局部变量：方法调用时自动生成，方法调用结束后消亡</li>
</ul>
</li>
<li><p>默认值</p>
<ul>
<li>成员变量：自动赋以类型的默认值（final修饰的成员变量需要显式地赋值）</li>
<li>局部变量：不会自动赋值</li>
</ul>
</li>
</ul>
<blockquote>
<p>**静态变量 **—— 由类的所有实例共享，通常被final修饰为常量使用。</p>
</blockquote>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul>
<li>修饰类——类不可被继承</li>
<li>修饰方法——方法不可以被子类覆盖，但是可以重载</li>
<li>修饰变量——变量一旦被赋值就不可以更改值<ul>
<li>成员变量：<ul>
<li>类变量（static修饰）——在静态代码块中指定初始值 &#x2F; 声明时指定初始值</li>
<li>成员变量 —— 非静态初始化块、声明变量、构造器中执行初始值</li>
</ul>
</li>
<li>局部变量：在使用变量前赋值，但不允许第二次赋值<ul>
<li>基本数据类型：一旦初始化后不可以更改</li>
<li>引用类型：对其初始化后不可以在指向另一个对象，但引用的值是可变的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="局部内部类和匿名内部类只能访问局部final变量？"><a href="#局部内部类和匿名内部类只能访问局部final变量？" class="headerlink" title="局部内部类和匿名内部类只能访问局部final变量？"></a>局部内部类和匿名内部类只能访问局部final变量？</h3><p>​	程序编译的时候会形成两个.class文件，除了本类还有内部类，但内部类和外部类同级别，并不会因为定义在方法中就会随着方法销毁。为了保证内部类可以在方法销毁后也可以访问局部变量，<strong>会将局部变量复制一份作为内部类的成员变量</strong>，但为了保证数据的一致性，<strong>将局部变量设置为final</strong>，对他初始化后就不允许再修改，使得局部变量和内部类建立的拷贝保持一致。</p>
<h3 id="Java-泛型，类型擦除【1】"><a href="#Java-泛型，类型擦除【1】" class="headerlink" title="Java 泛型，类型擦除【1】"></a>Java 泛型，类型擦除【1】</h3><ul>
<li>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型</li>
<li>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong></li>
<li>类型擦除：<strong>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉</strong></li>
</ul>
<h3 id="x3D-x3D-和-equals-的区别【3】"><a href="#x3D-x3D-和-equals-的区别【3】" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别【3】"></a>&#x3D;&#x3D; 和 equals() 的区别【3】</h3><ul>
<li>对基本类型来说，&#x3D;&#x3D;比较的是值，对引用类型来说比较的是地址 &#x2F; 引用是否相同</li>
<li>equals内部调用的仍然是&#x3D;&#x3D;，重写过后的（比如String类）比较的就是值（因为String类是引用类型，&#x3D;&#x3D;比较的就是地址）</li>
</ul>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>抽象类里除了抽象方法也可以有普通成员函数，而接口中只能存在public abstract方法</li>
<li>抽象类中的成员变量可以是各种类型的，但接口中只能存在public static final类型的，不能被修改且必须有初始值</li>
<li>抽象类只能继承一个，接口可以实现多个</li>
<li>抽象类是 is a 的关系（代码复用），接口是 like a 的关系（对类的行为进行约束）</li>
</ul>
<h3 id="序列化和反序列化【2】"><a href="#序列化和反序列化【2】" class="headerlink" title="序列化和反序列化【2】"></a>序列化和反序列化【2】</h3><ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
<li>常见应用场景：<ul>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象<em>存储到文件</em>之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
</li>
<li>对于不想进行序列化的<strong>变量</strong>，使用 <code>transient</code> 关键字修饰；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复，会被置成类型的默认值。</li>
<li><code>static</code> 变量（类变量）因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="List、Set、-Map-的区别。【2】"><a href="#List、Set、-Map-的区别。【2】" class="headerlink" title="List、Set、 Map 的区别。【2】"></a>List、Set、 Map 的区别。【2】</h3><blockquote>
<p>List, Set, Queue, Map 四者的区别？</p>
<ul>
<li><code>List</code>: 存储的元素是<strong>有序的</strong>、可重复的。</li>
<li><code>Set</code>: 存储的元素是无序的、<strong>不可重复的</strong>。</li>
<li><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>: 使用键值对（key-value）存储，<strong>key 不可重复，value可重复</strong>，每个键最多映射到一个值。</li>
</ul>
</blockquote>
<ul>
<li><strong>List</strong><ul>
<li><strong>有序、可重复的</strong></li>
<li>可以用Iterator取出所有元素，逐一遍历 &#x2F; get(index)方法取出元素</li>
<li><code>ArrayList</code>： <code>Object[]</code> 数组，线程不安全</li>
<li><code>Vector</code>：<code>Object[]</code> 数组，线程安全</li>
<li><code>LinkedList</code>： 双向链表，线程不安全</li>
</ul>
</li>
<li><strong>Set</strong><ul>
<li><strong>无序、不可重复的</strong></li>
<li>只能用Iterator取出所有元素，逐一遍历</li>
<li><code>HashSet</code>(无序，唯一)：基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素<ul>
<li>保证元素唯一，线程不安全</li>
<li>底层数据结构为HashMap(但仅存储对象)</li>
<li><strong>使用场景：不需保证元素插入和取出顺序时</strong></li>
</ul>
</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类<ul>
<li>保证元素唯一，线程不安全</li>
<li>底层数据结构为链表+哈希表</li>
<li><strong>使用场景：保证元素满足FIFO顺序时</strong></li>
</ul>
</li>
<li><code>TreeSet</code>(有序，唯一)：红黑树(自平衡的排序二叉树)<ul>
<li>保证元素唯一，线程不安全</li>
<li>底层数据结构为红黑树</li>
<li><strong>使用场景：对元素自定义排序规则时</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li><code>HashMap</code></li>
<li><code>LinkedHashMap</code></li>
<li><code>Hashtable</code></li>
<li><code>TreeMap</code></li>
</ul>
</li>
</ul>
<h3 id="ArrayList-和-LinkedList-的区别【4】"><a href="#ArrayList-和-LinkedList-的区别【4】" class="headerlink" title="ArrayList 和 LinkedList 的区别【4】"></a>ArrayList 和 LinkedList 的区别【4】</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th align="left">LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">底层数据机构</td>
<td align="left">Object[]存储，动态数组</td>
<td align="left">双向链表（JDK1.7取消使用双向循环链表）</td>
</tr>
<tr>
<td align="left">插入操作</td>
<td align="left">指定位置i——O(n-i)<br />末尾——O(1)</td>
<td align="left">指定位置i——O(n)<br />末尾——O(1)</td>
</tr>
<tr>
<td align="left">随机访问</td>
<td align="left">实现RandomAccess接口，可随机访问</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">空间消耗</td>
<td align="left">会在末尾预留一些空间 —— 占有内存空间</td>
<td align="left">每个元素都要消耗更多空间</td>
</tr>
<tr>
<td align="left">遍历</td>
<td align="left"></td>
<td align="left">使用Iterator而不是for循环</td>
</tr>
<tr>
<td align="left">扩容机制</td>
<td align="left">新建数组，复制数据到新数组</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">线程安全</td>
<td align="left">线程不安全</td>
<td align="left">线程不安全</td>
</tr>
<tr>
<td align="left">使用场景</td>
<td align="left">连续内存存储，适用于频繁的查找工作</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>LinkedList：</strong></p>
<ul>
<li>遍历时使用Iterator而不是for循环：<ul>
<li>每次for循环通过get(i)去取元素时都要重新遍历list，性能消耗极大</li>
<li>indexOf()返回元素索引也会遍历整个list，性能消耗极大</li>
</ul>
</li>
<li>内部维护了一个node内部类，插入时会创建node对象——大量插入时性能消耗较大</li>
</ul>
</blockquote>
<h3 id="HashMap、Hashtable、ConcurrentHashMap-的区别【5】"><a href="#HashMap、Hashtable、ConcurrentHashMap-的区别【5】" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap 的区别【5】"></a>HashMap、Hashtable、ConcurrentHashMap 的区别【5】</h3><p>现在面试的超高频考点。当面试官问到这个问题的时候，展现你背面试八股文能力的机会来了。</p>
<p>你可以展开去讲在 Java7 和 Java8 中 HashMap 分别采用什么数据结构，为什么 Java8 把之前的头插法改成了尾插法，怎样实现扩容，为什么负载因子是 0.75，为什么要用红黑树等等一系列的东西。只要面试官不打断我，我在这个知识点上能背到面试官下班。我最近也准备写一篇文章，详述上述知识点。</p>
<table>
<thead>
<tr>
<th></th>
<th>HashMap</th>
<th>Hashtable（基本淘汰）</th>
<th>ConcurrentHashMap</th>
</tr>
</thead>
<tbody><tr>
<td>线程安全</td>
<td>线程不安全</td>
<td>线程安全（synchronized修饰方法）</td>
<td>线程安全</td>
</tr>
<tr>
<td>效率</td>
<td>高</td>
<td></td>
<td></td>
</tr>
<tr>
<td>null值</td>
<td>可以存储null 的 key（仅一个） 和 value</td>
<td>不允许有 null 键和 null 值</td>
<td></td>
</tr>
<tr>
<td>默认初始容量</td>
<td>16</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>扩容机制（未给定初始值时）</td>
<td>2n</td>
<td>2n+1</td>
<td></td>
</tr>
<tr>
<td>底层数据结构</td>
<td>JDK1.8前：数组+链表<br />JDK1.8后：数组+链表+红黑树</td>
<td>数组+链表</td>
<td>JDK1.7 ：分段的数组+链表<br />JDK1.8 ：数组+链表&#x2F;红黑二叉树</td>
</tr>
</tbody></table>
<blockquote>
<p><code>HashMap</code> 总是使用 2 的幂作为哈希表的大小</p>
</blockquote>
<blockquote>
<p>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小</p>
</blockquote>
<blockquote>
<p><code>ConcurrentHashMap</code>实现线程安全的方式：</p>
<ul>
<li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
</ul>
</blockquote>
<h3 id="hashCode-和-equals-【4】"><a href="#hashCode-和-equals-【4】" class="headerlink" title="hashCode() 和 equals() 【4】"></a>hashCode() 和 equals() 【4】</h3><ul>
<li>HashSet进行存储的时候，先计算hash值，如果hash值相同则调用equals方法进行比较，不相同，则加入set</li>
<li>仅提供hashCode()：哈希算法可能会使不同的对象有相同的hash值（哈希碰撞），hashcode相同不一定代表对象一定相同</li>
<li>同时重写hashcode()和equals()：重写了equals方法后，可能会使两个内存地址不同的对象相等，但不重写hashcode方法时，由于内存地址不同，结果肯定不同，存储时可能会存储多个一样（主观上）的对象</li>
</ul>
<h3 id="重载和重写的区别。-【4】"><a href="#重载和重写的区别。-【4】" class="headerlink" title="重载和重写的区别。 【4】"></a>重载和重写的区别。 【4】</h3><ul>
<li>重载：<ul>
<li>在同一个类中</li>
<li>方法名必须相同</li>
<li>参数列表必须不同 —— 个数不同 &#x2F; 参数类型不同 &#x2F; 顺序不同</li>
<li>返回值和访问修饰符可以不同</li>
<li>发生在编译时<ul>
<li>编译器找不到匹配的参数时，会发生编译时错误 → 重载解析（overloading resolution）</li>
</ul>
</li>
</ul>
</li>
<li>重写：<ul>
<li>在父类与子类中</li>
<li>方法名、参数列表必须相同</li>
<li>返回值范围 &lt; 父类<ul>
<li>返回值重写时：<ul>
<li>void &#x2F; 基本数据类型：不可改</li>
<li>引用类型：可返回子类</li>
</ul>
</li>
</ul>
</li>
<li>抛出的异常范围 &lt;&#x3D; 父类</li>
<li>访问修饰符范围 &gt;&#x3D; 父类</li>
<li>父类方法访问修饰符为private时，不可以重写</li>
<li>发生在运行期</li>
</ul>
</li>
<li><strong>重载</strong>（编译器） —— 同一个类中多个同名方法根据不同地产参来执行不同的逻辑处理<ul>
<li>发生在同一个类当中 &#x2F; 父类与子类之间</li>
<li>方法名必须相同；参数类型、个数、顺序不同；返回值和访问修饰符可以不同</li>
<li>编译器挑选方法时，如果找不到匹配的参数就会产生编译时错误（这个过程称为重载解析（<code>overloading resolution</code>））</li>
</ul>
</li>
<li><strong>重写</strong>（运行期）—— 子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变<ul>
<li>方法名、参数列表必须相同</li>
<li>限制：<ul>
<li>子类方法返回值应 &lt;&#x3D; 父类方法返回值类型</li>
<li>子类抛出的异常范围 &lt;&#x3D; 父类抛出的异常范围</li>
<li>子类的访问修饰符范围 &gt;&#x3D; 父类的访问修饰符范围</li>
</ul>
</li>
<li>访问修饰符为 <code>private/final/static</code>的父类方法不可以被重写，但是被<code>static</code>修饰的方法能够被重新声明</li>
<li>构造方法无法被重写</li>
<li>返回值类型：<ul>
<li>void &#x2F; 基本数据类型 —— 重写是返回值不可修改</li>
<li>引用类型 —— 可以返回引用类型的子类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="深拷贝和浅拷贝。【1】"><a href="#深拷贝和浅拷贝。【1】" class="headerlink" title="深拷贝和浅拷贝。【1】"></a>深拷贝和浅拷贝。【1】</h3><h3 id="面向对象和面向过程的区别。【3】"><a href="#面向对象和面向过程的区别。【3】" class="headerlink" title="面向对象和面向过程的区别。【3】"></a>面向对象和面向过程的区别。【3】</h3><h3 id="面向对象三大特性是什么。并解释这三大特性。【3】"><a href="#面向对象三大特性是什么。并解释这三大特性。【3】" class="headerlink" title="面向对象三大特性是什么。并解释这三大特性。【3】"></a>面向对象三大特性是什么。并解释这三大特性。【3】</h3><ul>
<li><strong>封装</strong> —— 将对象的状态信息隐藏在对象内部，无法直接访问，可以通过外界可访问的方法获取</li>
<li><strong>继承</strong> —— 子类完全继承父类的基础上可进行扩展<ul>
<li>子类拥有父类所有的属性和方法（包括私有属性和私有方法——无法访问，只是拥有）</li>
<li>子类可以用自己的方式实现父类的方法</li>
</ul>
</li>
<li><strong>多态</strong> —— 一个对象具有多种状态，具体表现为父类的引用指向子类的实例<ul>
<li>对象类型和引⽤类型之间具有继承（类）&#x2F;实现（接⼝）的关系</li>
<li>引⽤类型变量发出的⽅法调⽤的到底是哪个类中的⽅法，必须在程序运⾏期间才能确定；</li>
<li>多态不能调⽤<strong>“只在⼦类存在但在⽗类不存在”</strong>的⽅法；</li>
<li>如果⼦类重写了⽗类的⽅法，真正执⾏的是<strong>⼦类覆盖的⽅法</strong>，如果⼦类没有覆盖⽗类的⽅法，执⾏的是⽗类的⽅法。</li>
</ul>
</li>
</ul>
<h3 id="String、StringBuffer-和-StringBuilder-的区别。-【4】"><a href="#String、StringBuffer-和-StringBuilder-的区别。-【4】" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别。 【4】"></a>String、StringBuffer 和 StringBuilder 的区别。 【4】</h3><ul>
<li>String：<ul>
<li>保存字符串的数组由final、private修饰，不可变；</li>
<li>每次操作会生成新的对象，导致内存浪费；</li>
<li>Java9后底部数组由char[]改为byte[]，因为在latin-1编码下，byte占一个字节，char占两个字节，可以节省50%的内存空间。</li>
<li>new一个String对象与直接” “有什么区别？</li>
</ul>
</li>
<li>StringBuilder：<ul>
<li>在原对象操作</li>
<li>线程不安全</li>
<li>‘+’ ：等同于 StringBuilder.append().toString()<ul>
<li>在循环内使用+，会在每次循环创建一个StringBuilder对象，浪费内存</li>
</ul>
</li>
</ul>
</li>
<li>StringBuffer：在原对象上操作，线程安全（方法都是synchronized修饰）</li>
<li>性能：StringBuilder &gt; StringBuffer &gt; String</li>
<li>使用场景：经常需要改变字符串内容时使用后面两个，优先使用StringBuilder，多线程使用共享变量时使用StringBuffer。</li>
</ul>
<h3 id="异常【3】"><a href="#异常【3】" class="headerlink" title="异常【3】"></a>异常【3】</h3><p>不会问的特别细。经常的问法是异常可以分为哪几种，然后你答了可检查异常和不可检查异常以后，会让你举例可检查异常有哪些，不可检查有哪些。</p>
<p>然后异常的代码要会写，有一场字节的面试，直接让我写一个把异常捕获了然后抛出去的代码。</p>
<h3 id="进程和线程的区别。【5】"><a href="#进程和线程的区别。【5】" class="headerlink" title="进程和线程的区别。【5】"></a>进程和线程的区别。【5】</h3><p>这是一个超高频考点，面试回答时别一句一个进程包含很多线程就没了。</p>
<p>要答清楚什么是线程什么是进程，线程和进程各自的运行状态、线程的通信方式和进程的通信方式。</p>
<h3 id="创建线程的方式。【4】"><a href="#创建线程的方式。【4】" class="headerlink" title="创建线程的方式。【4】"></a>创建线程的方式。【4】</h3><p>不仅要把创建线程的方式记熟、记住各种方式的优缺点，还要能写出代码来。有的面试官是会让你写代码创建两个线程然后执行一些操作的，比如两个线程交替输出数字。</p>
<h3 id="线程的生命周期？几种状态？"><a href="#线程的生命周期？几种状态？" class="headerlink" title="线程的生命周期？几种状态？"></a>线程的生命周期？几种状态？</h3><ul>
<li>创建状态 —— 新建线程对象</li>
<li>就绪状态 —— 调用该对象的start()后，变成可运行状态，等待获取CPU的使用权</li>
<li>运行状态 —— 就绪状态的线程获得了使用权，执行程序代码</li>
<li>阻塞状态 —— 线程由于某些原因放弃了CPU使用权，暂时停止运行直到线程重新进入就绪状态<ul>
<li>等待阻塞：wait()方法，释放所有资源（包括锁），等待notify()唤醒</li>
<li>同步阻塞：运行的线程未获取到同步锁，JVM将其放入锁池</li>
<li>其他阻塞：执行sleep() &#x2F; join()方法 &#x2F; 发出IO请求，JVM将其置为阻塞状态</li>
</ul>
</li>
<li>死亡状态 —— 线程执行完毕 &#x2F; 因异常退出了run()方法，线程结束生命周期</li>
</ul>
<h3 id="sleep-、wait-、join-、yield-的区别"><a href="#sleep-、wait-、join-、yield-的区别" class="headerlink" title="sleep()、wait()、join()、yield()的区别"></a>sleep()、wait()、join()、yield()的区别</h3><ul>
<li>join() ：线程A调用join方法后，使调用线程A的线程B进入阻塞状态，直到线程A结束或中断</li>
<li>yield() ：执行后线程进入就绪状态，暂时让出CPU执行权，等待分配CPU使用权</li>
<li>sleep() ：会让出CPU执行时间并且强制上下文切换 —— 用于当前线程休眠 &#x2F; 轮询暂停操作</li>
<li>wait() ：用于多线程之间的通信</li>
</ul>
<h3 id="什么是死锁，死锁如何产生，如何避免【5】"><a href="#什么是死锁，死锁如何产生，如何避免【5】" class="headerlink" title="什么是死锁，死锁如何产生，如何避免【5】"></a>什么是死锁，死锁如何产生，如何避免【5】</h3><p>超高频问题，几乎大厂的一面和二面都会问到。</p>
<h3 id="线程安全？"><a href="#线程安全？" class="headerlink" title="线程安全？"></a>线程安全？</h3><ul>
<li>线程安全指的是内存安全，堆是共享内存，可以被所有线程访问</li>
<li>堆是进程线程共有的空间，分为全局堆和局部堆。全局堆是没有分配的空间，局部堆是用户分配的空间。<ul>
<li>堆在操作系统对进程初始化的时候创建（虚拟机启动时），唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</li>
<li>运行过程中可以向系统要额外的堆，但是用完了要还给操作系统，否则就是内存泄露</li>
</ul>
</li>
<li>栈是线程独有的，所以是线程安全的，是保存其运行状态的局部自动变量的<ul>
<li>在线程开始时初始化</li>
<li>操作系统在切换线程的时候会自动切换栈</li>
</ul>
</li>
</ul>
<h3 id="synchronized-锁升级流程。【5】"><a href="#synchronized-锁升级流程。【5】" class="headerlink" title="synchronized 锁升级流程。【5】"></a>synchronized 锁升级流程。【5】</h3><p>这又是面试八股文的一大考点，锁升级流程记清楚。</p>
<h3 id="volatile-关键字【5】"><a href="#volatile-关键字【5】" class="headerlink" title="volatile 关键字【5】"></a>volatile 关键字【5】</h3><p>对比和 synchronized 的区别。</p>
<h3 id="乐观锁和悲观锁的区别【5】"><a href="#乐观锁和悲观锁的区别【5】" class="headerlink" title="乐观锁和悲观锁的区别【5】"></a>乐观锁和悲观锁的区别【5】</h3><h3 id="ThreadLocal【4】"><a href="#ThreadLocal【4】" class="headerlink" title="ThreadLocal【4】"></a>ThreadLocal【4】</h3><ul>
<li>使用场景：<ul>
<li>在对象进行跨层传递时，使用参数列表一层一层传较为繁琐，使用ThreadLocal可以避免多次传递，存储在线程的ThreadLocalMap（线程本地变量）中，打破层次间的约束</li>
<li>线程私有的，所以不存在线程安全性问题，线程间数据隔离</li>
<li>进行事务操作，用于存储线程事务信息</li>
<li>数据库连接，session会话管理</li>
</ul>
</li>
<li>ThreadLocal内存泄漏：<ul>
<li>不在会被使用的对象或者变量占用的内存不可回收——内存泄漏  ！&#x3D; OOM（内存不够）</li>
<li>强引用：new &#x2F; 反射创建的对象都是强引用，这样不会被垃圾回收器回收<ul>
<li>内存空间不足时，JVM会抛出OutOfMemoryError错误，也不会回收这种对象</li>
<li>显式赋值为null时，表明可以进行回收</li>
</ul>
</li>
<li>弱引用：<ul>
<li>JVM无论内存够不够，都会回收弱引用的对象</li>
<li>java.lang.ref.WeakReference类的对象</li>
<li>可以在缓存中使用弱引用，缓存中回收也没关系，可以重新建立</li>
</ul>
</li>
<li>根源：ThreadLocalMap的生命周期和Thread一样长，如果没有手动删除对应key就会导致内存泄露，而不是因为弱引用。</li>
<li>正确的使用：<ul>
<li>每次使用完ThreadLocal都调用remove()方法清除数据</li>
<li>将ThreadLocal遍历定义为private static ，这样就一直存在ThreadLocal的强引用，也能保证任何时候都能通过ThreadLocal的弱引用访问的Entry的值，进而清除掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程池【5】"><a href="#线程池【5】" class="headerlink" title="线程池【5】"></a>线程池【5】</h3><p>超高频考点。需要答出线程池有哪几种，各种线程池的优缺点，线程池的重要参数、线程池的执行流程、线程池的饱和策略、如何设置线程池的大小等等。这里也能背十几分钟。</p>
<h3 id="ReentrantLock-和-AQS。【4】"><a href="#ReentrantLock-和-AQS。【4】" class="headerlink" title="ReentrantLock 和 AQS。【4】"></a>ReentrantLock 和 AQS。【4】</h3><p>其实我在面试的时候对这里不是很熟，我面试的时候尽量不提到这里，也苟过去了。大家如果时间充足的话还是把这块好好理解一下。如果这里理解透彻了，也能在这里和面试官聊很久。</p>
<h3 id="JVM怎么判断哪些对象可以回收"><a href="#JVM怎么判断哪些对象可以回收" class="headerlink" title="JVM怎么判断哪些对象可以回收"></a>JVM怎么判断哪些对象可以回收</h3><ul>
<li>可达性分析：从GCRoots 开始向下搜索，搜索走过的路径称为引用链。当一个对象到root没有任何引用链相连时，证明此对象不可用，虚拟机判断为可回收对象，进行一次标记，两次标记后直接回收。</li>
<li>引用分析：被引用就+1，引用结束-1，等于0就回收</li>
</ul>
<h3 id="BufferCache"><a href="#BufferCache" class="headerlink" title="BufferCache"></a>BufferCache</h3><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul>
<li>索引&amp;联合索引</li>
<li>如何分库分表</li>
</ul>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="CAP理论、BASE理论"><a href="#CAP理论、BASE理论" class="headerlink" title="CAP理论、BASE理论"></a>CAP理论、BASE理论</h2><ul>
<li>CAP理论<ul>
<li>consistency（一致性）：即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终—致。</li>
<li>Availability（可用性）：即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</li>
<li>Partition Tolerance（分区容错性）：即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</li>
<li>CP和AP：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能2选1</li>
</ul>
</li>
<li>BASE理论<ul>
<li>BASE是Basically Available (基本可用) 、Soft state(软状态)、Eventually consistent(最终一致性)</li>
<li>BASE理论是对CAP中<strong>一致性和可用性权衡的结果</strong>，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。</li>
<li>BASE理论的核心思想是:即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终—致性。</li>
<li>基本可用：<ul>
<li>响应时间上的损失:正常情况下，处理用户请求需要0.5s返回结果，但是由于系统出现故障，处理用户请求的时间变为3 s。</li>
<li>系统功能上的损失:正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
</li>
<li>软状态：数据同步允许一定的延迟</li>
<li>最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时</li>
</ul>
</li>
</ul>
<h2 id="负载均衡算法、类型"><a href="#负载均衡算法、类型" class="headerlink" title="负载均衡算法、类型"></a>负载均衡算法、类型</h2><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><ul>
<li>轮询法：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li>
<li>随机法：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</li>
<li>源地址哈希法：源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li>
<li>加权轮询法：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li>
<li>加权随机法：与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</li>
<li>最小连接数法：最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理(快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>DNS（域名解析）方式实现负载均衡——效率高</li>
<li>硬件负载均衡：F5和A10</li>
<li>软件负载均衡：Nginx、HAproxy 、LVS<ul>
<li>其中的区别:<ul>
<li>Nginx：<ul>
<li>七层（应用层）负载均衡，支持 HTTP、E-mail 协议</li>
<li>同时也支持4层负载均衡</li>
<li>和客户端、服务端各有一个长连接——消耗资源、性能低</li>
<li>解析url，根据一定规则进行路由</li>
</ul>
</li>
<li>HAproxy（高可用代理器）：支持七层规则的，性能也很不错（OpenStack默认使用的负或均衡软件就是HAproxy）</li>
<li>LVS：运行在内核态，性能是软件负载均衡中最高的，在传输层负载均衡（替换指向LVS代理器的目标IP为代理的机器的IP,然后转发），严格来说工作在三层，所以更通用一些，适用各种应用服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何进行Session共享"><a href="#如何进行Session共享" class="headerlink" title="如何进行Session共享"></a>如何进行Session共享</h2><p>session（存在内存中）一般保存用户的登录态，单体应用下可以正常运行，但分布式情况下，经由负载均衡时可能在登陆时和使用其他服务时连接到了不同的服务器，导致session不同步，如何解决？</p>
<ul>
<li>采用无状态服务，抛弃session（使用JWT &#x2F; token）</li>
<li>存入cookie（有安全风险）（存在客户端——浏览器）</li>
<li>服务器之间进行Session同步，这样可以保证每个服务器上都有全部的Session信息，不过当服务器数量比较多的时候，占资源，同步是会有延迟甚至同步失败；</li>
<li>IP绑定策略：使用Nginx(或其他复杂均衡软硬件）中的IP绑定策略，同一个IP只能在指定的同一个机器访问，但是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大;</li>
<li>使用Redis存储：把Session放到Redis 中存储，虽然架构上变得复杂，并且需要多访问一次Redis，但是这种方案带来<br>的好处也是很大的：<ul>
<li>实现了Session共享;</li>
<li>可以水平扩展（增加Redis服务器);</li>
<li>服务器重启Session不丢失(不过也要注意Session在Redis 中的刷新&#x2F;失效机制)</li>
<li>不仅可以跨服务器Session共享，甚至可以跨平台（例如网页端和APP端) &#x2F; 跨语言。</li>
</ul>
</li>
</ul>
<h2 id="RPC、RMI（RPC的java实现版本）"><a href="#RPC、RMI（RPC的java实现版本）" class="headerlink" title="RPC、RMI（RPC的java实现版本）"></a>RPC、RMI（RPC的java实现版本）</h2><ul>
<li><p><strong>RPC</strong>：在本地调用远程的函数，远程过程调用，可以跨语言实现	httpClient</p>
</li>
<li><p><strong>RMI：</strong>远程方法调用，java中用于实现RPC的一种机制，RPC的java版本，是J2EE的网络调用机制，跨JVM调用对象的方法，面向对象的思维方式（调用与被调用都需要是java开发）</p>
<ul>
<li><p>直接或间接实现接口<strong>java.rmi.Remote</strong>，成为存在于服务器端的远程对象，供客户端访问并提供一定的服务</p>
</li>
<li><p>远程对象必须实现<strong>java.rmi.server.UnicastRemoteObject</strong>类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为”存根”，而服务器端本身已存在的远程对象则称之为”骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的之后调用远程方法来响应客户端的请求。</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public interface Iservice extends Remote{&#x2F;&#x2F;成为存在于服务器端的远程对象，供客户端访问并提供一定的服务<br>String service(string content) throws RemoteException;<br>}</p>
<p>public class ServiceImpl extends UnicastRemoteobject implements IService {&#x2F;&#x2F;远程对象将会把自身的一个拷贝以Socket的形式传输给客户端<br>private String name ;<br>public ServiceImpl(String name） throws RemoteException{<br>    this.name &#x3D; name;<br>}<br><br>@Override<br>public String Service(string content) {<br>    return “server &gt;&gt;” + content;<br>}<br>}<br>public class Server{ &#x2F;&#x2F;服务端<br>public static void main(string[]args){<br>    try{<br>        IService service02 &#x3D; new ServiceImpl( “service02”);<br>        Context namingcontext &#x3D; new Initia1context(); &#x2F;&#x2F;JVM提供的注册表机制(要手动启动)<br>        namingcontext.rebind(“rmi:&#x2F;&#x2F;127.0.0.1&#x2F;service02”，service02);<br>    }catch (Exception e){<br>        e.printstackTraceo;<br>    }<br>    System.out.print1n (“000000! “);<br>}<br>}<br>public class client{ &#x2F;&#x2F;客户端<br>public static void main(string[] args){<br>    String url &#x3D; “rmi :&#x2F;&#x2F;127.0.0.1&#x2F;“;<br>    try{<br>        context namingcontext &#x3D; new Initialcontext();<br>        Iservice service02 &#x3D; (Iservice) namingcontext.lookup(url + “service02”);&#x2F;&#x2F;从注册表找服务调用<br>        C1ass stubClass &#x3D; service02.getClass();<br>        System.out.print1n(service02 + “ is “ + stubc1ass.getName();<br>        &#x2F;&#x2F;com.sun. proxy . SProxyo<br>        Class [] interfaces &#x3D; stubc1ass.getInterfaces();<br>        for(Class c : interfaces){<br>            System.out.println(“imp1ement” + c.getName() + “ interface”);<br>        }<br>        System.out.println(serviceo2.service(“he11o”));<br>    }catch (Exception e){<br>        e .printstackTrace();<br>    }<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分布式id生成方案</span><br><span class="line"></span><br><span class="line">- UUID（本身唯一性）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>全局唯一如何保证？<br>    1.当前日期和时间	时间戳<br>    2.时钟序列	计数器<br>    3.全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。<br>优点：代码简单，性能好（本地生成，没有网络消耗），保证唯一（相对而言，重复概率极低可以忽略）<br>缺点：<br>    1.每次生成的ID都是无序的,而且不是全数字,且无法保证趋势递增。（对数据库聚簇索引不友好）<br>    2.UUID生成的是字符串，字符串存储性能差，查询效率慢，写的时候由于不能产生顺序的append操作，需要进行insert操作，导致频繁的页分裂，这种操作在记录占用空间比较大的情况下，性能下降比较大，还会增加读取磁盘次数<br>    3.UUID长度过长，不适用于存储，耗费数据库性能。<br>    4.ID无一定业务含义，可读性差。<br>    5.有信息安全问题，有可能泄露mac地址（有机器识别号）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 数据库自增序列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>单机模式:<br>    优点:<br>        1.实现简单，依靠数据库即可，成本小。<br>        2.ID数字化，单调自增,满足数据库存储和查询性能。<br>        3.具有一定的业务可读性。（结合业务code）<br>    缺点:<br>        1.强依赖DB，存在单点问题,如果数据库宕机,则业务不可用。<br>        2.DB生成ID性能有限,单点数据库压力大,无法扛高并发场景。<br>        3.信息安全问题，比如暴露订单量，url查询改一下id查到别人的订单</p>
<p>数据库高可用:多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于节点数<br>    优点:解决了ID生成的单点问题,同时平衡了负载。<br>    缺点:<br>        1.系统扩容困难:系统定义好步长之后，增加机器之后调整步长困难。<br>        2.数据库压力大:每次获取一个ID都必须读写一次数据库。<br>        3.主从同步的时候:电商下单-&gt;支付insert master db select数据﹐因为数据同步延迟导致查不到这个数据。加cache（不是最好的解决方式）数据要求比较严谨的话查master主库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Leaf-segment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一、采用每次获取一个ID区间段的方式来解决，区间段用完之后再去数据库获取新的号段，这样一来可以大大减轻数据库的压力<br>核心字段:biz_tag，max_id, step<br>    biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度，原来每次获取ID都要访问数据库，现在只需要把Step设置的足够合理如1000，那么现在可以在1000个ID用完之后再去访问数据库<br>优点:<br>    1.扩张灵活，性能强能够撑起大部分业务场景。<br>    2.ID号码是趋势递增的,满足数据库存储和查询性能要求。<br>    3.可用性高，即使ID生成服务器不可用，也能够使得业务在短时间内可用，为排查问题争取时间。<br>缺点:可能存在多个节点同时请求ID区间的情况，依赖DB</p>
<p>二、双buffer（优化）:将获取一个号段的方式优化成获取两个号段，在一个号段用完之后不用立马去更新号段，还有一个缓存号段备用，这样能够有效解决这种冲突问题，而且采用双buffer的方式，在当前号段消耗了10%的时候就去检查下一个号段有没有准备好，如果没有准备好就去更新下一个号段，当前号段用完了就切换到下一个已经缓存好的号段去使用，同时在下一个号段消耗到10%的时候，又去检测下一个号段有没有准备好，如此往复。</p>
<p>优点:基于VM存储双buffer的号段，减少了数据库查询，减少了（对数据库的）网络依赖，效率更高。<br>缺点:<br>    1.segment号段长度是固定的，业务量大时可能会频繁更新号段，因为原本分配的号段会一下用完<br>    2.如果号段长度设置的过长，但凡缓存中有号段没有消耗完，其他节点重新获取的号段与之前相比可能跨度会很大，动态调整Step</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 基于redis（比mysql吞吐量更大，并发）、mongoDB、zk等中间件生成</span><br><span class="line"></span><br><span class="line">- 雪花算法（best）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成一个64bit的整性数字<br>第一位符号位固定为0，41位时间戳，10位workId（机器号，给分布式集群中每个机器定的id），12位序列号<br>（位数可以有不同实现）</p>
<p>优点:<br>    1.每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。<br>    2.时间戳值在高位，中间是固定的机器码，白增的序列在低位，整个ID是趋势递增的。<br>    3.能够根据业务场景数据库节点布置灵活挑战bit位划分，灵活度高。<br>缺点:强依赖于机器时钟，如果时钟回拨（自己设置系统时间），会导致重复的ID生成，所以一般基于此的算法发现时钟回拨，都会抛异常处理,阻止ID生成，这可能导致服务不可用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分布式锁</span><br><span class="line"></span><br><span class="line">需要这个锁独立于每一个服务之外，而不是在服务里面。</span><br><span class="line"></span><br><span class="line">- 数据库：利用主键冲突控制一次只有一个线程能获取锁，</span><br><span class="line">  - 非阻塞、不可重入（递归时）、单点、失效时间</span><br><span class="line">- Zookeeper分布式锁：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>zk通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应（结束线程后，唤醒阻塞队列中哪个线程）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **Redis分布式锁**：setNX命令，单线程处理网络请求，不需要考虑并发安全性</span><br><span class="line"></span><br><span class="line">  所有服务节点设置相同的key，返回为0、则锁获取失败</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>setnx<br>问题:<br>    1、早期版本没有超时参数，需要单独设置，存在死锁问题（中途宕机&gt;<br>    2、后期版本提供加锁与设置时间原子操作，但是存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题（可以在value中放一个自动生成的uuid，和锁比较过后一致则删除）<br>        2.1、删除锁：判断线程唯一标志，再删除<br>可重入性及锁续期（任务未完成，过期时间到释放锁）没有实现，通过redisson解决（类似AQS的实现，看门狗监听机制（判断是否执行完成，未完成重设key的过期时间）</p>
<p>&#96;&#96;&#96;</p>
<ul>
<li>redlock：意思的机制都只操作单节点、即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发牛了主从切换，那么就会出现锁丢失的情况。（redis同步设置可能数据丢失）——redlock从多个节点申请锁，当一半以上节点获取成功、锁才算获取成功，redission有相应的实现</li>
</ul>
<h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><ul>
<li><p>场景：一个方法里面操作两个数据源 &amp; 两个不同的节点上的两个数据源</p>
</li>
<li><p>问题：两个数据源共同的提交、共同回滚、保证事务原子性</p>
</li>
<li><p>解决方案：</p>
<ul>
<li><p>XA规范：分布式事务规范。定义了分布式事务模型</p>
<ul>
<li><p>四个角色：事务管理器(协调者TM)、资源管理器(参与者RM)、应用程序AP、通信资源管理器CRM</p>
</li>
<li><p>全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚</p>
</li>
<li><p>JTA事务：java对XA规范的实现，对应JDBC的单库事务</p>
</li>
<li><p>具体实现：</p>
<ul>
<li><p>两阶段协议：</p>
<ul>
<li>①第一阶段（ prepare ) ：发送prepare消息（基本完成sql语句操作），但未提交事务；每个参与者执行本地事务但不提交，进入ready状态，并通知协调者已经准备就绪。</li>
<li>②第二阶段（commit）：当协调者确认每个参与者都ready后，通知参与者进行commit 操作；如果有参与者fail则发送rollback命令，各参与者做回滚。如果阶段一所有prepare操作成功 &#x2F; 失败，则通知所有库提交事务 &#x2F; 回滚事务</li>
</ul>
</li>
<li><p>两阶段协议问题：</p>
<ul>
<li>单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）</li>
<li>数据不一致：在阶段二，如果事务管理器只发送了部分commit消息，此时网络发生异常，那么只有部分参与者接收到commit消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li>响应时间较长：参与者和协调者资源都被锁住，提交或者回滚之后才能释放</li>
<li>不确定性：当协事务管理器发送commit之后，并且此时只有一个参与者收到了commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li>
</ul>
</li>
<li><p>三阶段协议：主要是针对两阶段的优化，解决了单点故障的问题，但是性能问题&amp;不一致问题仍没有根本解决（引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc只有协调者有超时机制）</p>
<ul>
<li>阶段一：TM发送CanCommit消息，确认数据库环境正常：协调者询问事务参与者，是否有能力完成此次事务。<ul>
<li>如果都返回yes，则进入第二阶段</li>
<li>有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求</li>
</ul>
</li>
<li>阶段二：发送PreCommit消息，此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作。参与者执行完事务操作后（此时属于未提交事务的状态)，就会向协调者反馈”Ack”表示我已经准备好提交了，并等待协调者的下一步指令。</li>
<li>阶段三：发送DoCommit消息，通知所有库提交 &#x2F; 回滚事务。在阶段二中如果所有的参与者节点都返回了Ack，那么协调者就会从”预提交状态”转变为”提交状态”。然后向所有的参与者节点发送”doCommit”请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈”Ack”消息，协调者收到所有参与者的Ack消息后完成事务。相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。</li>
</ul>
</li>
<li><p>TCC(补偿事务)：Try、Confirm（commit）、Cancel（业务层面上的rollback）</p>
<ul>
<li>针对每个操作，都要注册一个与其对应的确认和补偿(撤销)操作</li>
<li>Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作既回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm &#x2F; Cancel操作若执行失败，TM会进行重试。</li>
<li>TCC模型对<strong>业务的侵入性较强，改造的难度较大</strong>，每个操作都需要有try、confirm、cancel三个接口实现</li>
<li>confirm和cancel接口还必须实现幂等性。</li>
</ul>
</li>
<li><p>消息队列的事务消息</p>
<ul>
<li>发送prepare消息到消息中间件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>发送成功后，执行本地事务</p>
<ul>
<li><p>如果事务执行成功，则commit，消息中间件将消息下发至消费端(commit前，消息不会被消费)。</p>
</li>
<li><p>如果事务执行失败。则回滚，消息中间件将这条prepare消息删除<br>- 消费端接收到消息进行消费。如果消费失败，则不断重试</p>
</li>
</ul>
</li>
</ul>
<h2 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h2><p>高并发场景下，相同的参数重复点击时保证数据正确</p>
<ul>
<li>唯—id：每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在则执行后续操作，并且保存到数据库或者redis等。</li>
<li>服务端提供发送token的接口，业务调用接口前先获取token，然后调用业务接口请求时，把token携带过去，服务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除</li>
<li>建去重表：将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了</li>
<li>版本控制：增加版本号，当版本号符合时，才能更新数据（类似乐观锁）</li>
<li>状态控制：例如订单有状态已支付、未支付、支付中、支付失败，前置后续条件，当处于未支付的时候才允许修改为支付中等</li>
</ul>
<h1 id="Zookeeper——分布式协调服务"><a href="#Zookeeper——分布式协调服务" class="headerlink" title="Zookeeper——分布式协调服务"></a>Zookeeper——分布式协调服务</h1><h2 id="ZAB协议（zk专用）"><a href="#ZAB协议（zk专用）" class="headerlink" title="ZAB协议（zk专用）"></a>ZAB协议（zk专用）</h2><ul>
<li><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，实现分布式数据一致性（CAP理论中的C——强一致性）（选择了CP）</p>
</li>
<li><p>所有客户端的请求都是写入到Leader进程中，然后由Leader同步到其他节点，称为Follower（主从）。在集群数据同步的过程中，如果出现 Follower节点崩溃或者Leader进程崩溃时，都会通过ZAB协议来保证数据一致性</p>
</li>
<li><p>ZAB协议包括两种基本的模式：<strong>崩溃恢复</strong>和<strong>消息广播</strong></p>
<ul>
<li>消息广播:<ul>
<li>集群中所有的事务请求都由Leader节点来处理，其他服务器为Follower，Leader将客户端的事务请求转换为事务Proposal，并且将Proposal 分发给集群中其他所有的Follower。</li>
<li>完成广播之后，Leader等待Follwer反馈，当有过半数的Follower反馈信息后，Leader将再次向集群内Follower广播Commit信息，Commit信息就是确认将之前的 Proposal提交。</li>
<li>Leader节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作，其中过半数指的是反馈的节点数&gt;&#x3D;N&#x2F;2+1，N是全部的Follower节点数量。</li>
</ul>
</li>
<li>崩溃恢复：（此时不可用）<ol>
<li>初始化集群，刚刚启动的时候</li>
<li>Leader崩溃，因为故障宕机</li>
<li>Leader 失去了半数的机器支持，与集群中超过一半的节点断连</li>
</ol>
<ul>
<li>此时开启新一轮Leader选举，选举产生的Leader会与过半的Follower进行同步，使数据一致，当与过半的机器同步完成后，就退出恢复模式，然后进入消息广播模式</li>
</ul>
</li>
</ul>
</li>
<li><p>整个ZooKeeper集群的一致性保证就是在上面两个状态之前切换，当Leader服务正常时，就是正常的消<strong>息广播模式</strong>；当Leader不可用时，则进入<strong>崩溃恢复模式</strong>，崩溃恢复阶段会进行数据同步，完成以后，重新进入消息广播阶段。</p>
</li>
<li><p><strong>Zxid</strong>：Zab协议的一个事务编号，Zxid是一个64位的数字，其中低32位是一个简单的单调递增计数器，针对客户端每一个事务请求，计数器加1;而高32位则代表Leader周期年代的编号。</p>
</li>
<li><p>Leader周期( epoch），可以理解为当前集群所处的年代或者周期，每当有一个新的Leader选举出现时，就会从这个Leader服务器上取出其本地日志中最大事务的Zxid，并从中读取epoch值，然后加1，以此作为新的周期ID。高32位代表了每代Leader的唯一性，低32位则代表了每代Leader中事务的唯一性。</p>
</li>
<li><p>zab节点的三种状态：</p>
<ul>
<li>following：服从leader的命令</li>
<li>leading：负责协调事务</li>
<li>election&#x2F;looking：选举状态（崩溃恢复阶段）</li>
</ul>
</li>
</ul>
<h2 id="zk的数据模型和节点类型"><a href="#zk的数据模型和节点类型" class="headerlink" title="zk的数据模型和节点类型"></a>zk的数据模型和节点类型</h2><ul>
<li><strong>数据模型</strong>——树形结构<ul>
<li>zk维护的数据主要有：客户端的会话（session）状态及数据节点（dataNode）信息。</li>
<li>zk在内存中构造了个DataTree的数据结构，维护着path到dataNode的映射以及dataNode间的树状层级关系。为了提高读取性能，集群中每个服务节点都是将数据全量存储在内存中。所以zk最适于<strong>读多写少且轻量级数据的应用场景</strong>。</li>
<li>数据仅存储在内存是很不安全的，zk采用事务日志文件及快照文件的方案来落盘数据，保障数据在不丢失的情况下能快速恢复。</li>
<li>树中的每个节点被称为一Znode</li>
<li>Znode兼具文件和目录两种特点。可以做路径标识，也可以存储数据，并可以具有子Znode。具有增、删、改、查等操作。</li>
<li>Znode具有原子性操作，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作</li>
<li>Znode存储数据大小有限制。每个Znode的数据大小至多1M，常规使用中应该远小于此值。</li>
<li>Znode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示（没有相对路径），因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串”&#x2F;zookeeper”用以保存管理信息，比如关键配额信息。</li>
</ul>
</li>
<li><strong>节点类型</strong>：<ul>
<li>持久节点：一旦创建、该数据节点会一直存储在zk服务器上、即使创建该节点的客户端与服务端的会话关闭了该节点也不会被删除</li>
<li>临时节点：当创建该节点的客户端会话因超时或发生异常而关闭时、该节点也相应的在zk上被删除。</li>
<li>有序节点：不是一种单独种类的节点、而是在持久节点和临时节点的基础上、增加了一个节点有序的性质</li>
</ul>
</li>
</ul>
<h2 id="zk的命名服务、配置管理、集群管理——三种使用场景"><a href="#zk的命名服务、配置管理、集群管理——三种使用场景" class="headerlink" title="zk的命名服务、配置管理、集群管理——三种使用场景"></a>zk的命名服务、配置管理、集群管理——三种使用场景</h2><ul>
<li>命名服务：通过指定的名字来获取资源或者服务地址。Zookeeper可以创建一个全局唯一的路径，这个路径就可以作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服务框架(RPC、RMI)中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取资源的实体、服务地址和提供者信息等</li>
<li>配置管理：实际项目开发中，经常使用.properties或者xml需要配置很多信息，如数据库连接信息、fps地址端口等等。程序分布式部署时，如果把程序的这些配置信息保存在zk的znode节点下，当你要修改配置，即znode会发生变化时，可以通过改变k中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。<ul>
<li><strong>watch机制</strong>（监听机制）——客户端可以通过在znode上设置watch，实现实时监听znode的变化<ul>
<li>Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端<ul>
<li>父节点的创建，修改，部除都会触发Watcher事件。</li>
<li>子节点的创建，册除会触发Watcher事件。</li>
</ul>
</li>
<li>一次性：一旦被触发就会移除，再次使用需要重新注册，因为每次变动都需要通知所有客户端，一次性可以减轻压力，3.6.0默认持久递归，可以触发多次</li>
<li>轻量：只通知发生了事件，不会告知事件内容，减轻服务器和带宽压力</li>
<li>Watcher机制包括三个角色：客户端线程、客户端的 WatchManager、ZooKeeper服务器<ol>
<li>客户端向ZooKeeper 服务器注册一个Watcher监听</li>
<li>把这个监听信息存储到客户端的WatchManager中</li>
<li>当ZooKeeper 中的节点发生变化时，会通知客户端，客户端会调用相应Watcher对象中的回调方法（watch回调是串行同步的）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>集群管理：集群管理包括集群监控和集群控制，就是监控集群机器状态，剔除机器和加入机器。zookeeper可以方便集群机器的管理，它可以实时监控znode节点的变化，一旦发现有机器挂了，该机器就会与zk断开连接，对应的临时目录节点会被删除，其他所有机器都收到通知，新机器加入也是类似。</li>
</ul>
<h2 id="zk与eureka的区别（CAP理论）"><a href="#zk与eureka的区别（CAP理论）" class="headerlink" title="zk与eureka的区别（CAP理论）"></a>zk与eureka的区别（CAP理论）</h2><ul>
<li>zk：CP设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。<ul>
<li>当节点crash后，需要进行leader的选举，在这个期间内，zk服务是不可用的。</li>
</ul>
</li>
<li>eureka：AP设计(高可用)，目标是一个服务注册发现系统，专门用于微服务的服务发现注册。<ul>
<li>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)</li>
<li>同时当eureka的服务端发现85%以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会从服务列表中删除这些失去心跳的服务，同时eureka的客户端也会缓存服务信息。eureka对于服务注册发现来说是非常好的选择。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">LLoyyj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1/">八股</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/18/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"><img class="prev-cover" src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">算法题解题思路</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/13/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="next-cover" src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MySQL学习笔记（一）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/01/18/算法题解题思路/" title="算法题解题思路"><img class="cover" src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-18</div><div class="title">算法题解题思路</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://s2.loli.net/2023/01/11/1NsbGvmfukWXBQM.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LLoyyj</div><div class="author-info__description">属于我人生的一小步</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LLoyyJ"><i class="fab fa-github"></i><span>关注我一下下？</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">你自己偷偷知道就好啦 ~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9%E3%80%902%E3%80%91"><span class="toc-number">1.0.1.</span> <span class="toc-text">Java语言的特点【2】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-JVM-%E5%92%8C-JDK-%E4%BB%A5%E5%8F%8A-JRE%E3%80%902%E3%80%91"><span class="toc-number">1.0.2.</span> <span class="toc-text">比较 JVM 和 JDK 以及 JRE【2】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Java-%E8%AF%AD%E8%A8%80%E2%80%9C%E8%A7%A3%E9%87%8A%E4%B8%8E%E7%BC%96%E8%AF%91%E5%B9%B6%E5%AD%98%E2%80%9D%E3%80%902%E3%80%91"><span class="toc-number">1.0.3.</span> <span class="toc-text">为什么说 Java 语言“解释与编译并存”【2】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%90%84%E5%8D%A0%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%9F%E3%80%902%E3%80%91"><span class="toc-number">1.0.4.</span> <span class="toc-text">Java 基本类型有哪几种，各占多少位？【2】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-vs-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">基本数据类型 vs 包装类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">包装类型的缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">自动装箱与拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">浮点数精度丢失问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E8%BF%87long%E6%95%B4%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">超过long整型的数据如何表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%E3%80%903%E3%80%91"><span class="toc-number">1.0.5.</span> <span class="toc-text">成员变量与局部变量的区别。【3】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.0.6.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AA%E8%83%BD%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8final%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">1.0.7.</span> <span class="toc-text">局部内部类和匿名内部类只能访问局部final变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E6%B3%9B%E5%9E%8B%EF%BC%8C%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E3%80%901%E3%80%91"><span class="toc-number">1.0.8.</span> <span class="toc-text">Java 泛型，类型擦除【1】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%903%E3%80%91"><span class="toc-number">1.0.9.</span> <span class="toc-text">&#x3D;&#x3D; 和 equals() 的区别【3】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.10.</span> <span class="toc-text">接口和抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%902%E3%80%91"><span class="toc-number">1.0.11.</span> <span class="toc-text">序列化和反序列化【2】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E3%80%81Set%E3%80%81-Map-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%E3%80%902%E3%80%91"><span class="toc-number">1.0.12.</span> <span class="toc-text">List、Set、 Map 的区别。【2】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%904%E3%80%91"><span class="toc-number">1.0.13.</span> <span class="toc-text">ArrayList 和 LinkedList 的区别【4】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E3%80%81Hashtable%E3%80%81ConcurrentHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%905%E3%80%91"><span class="toc-number">1.0.14.</span> <span class="toc-text">HashMap、Hashtable、ConcurrentHashMap 的区别【5】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-%E5%92%8C-equals-%E3%80%904%E3%80%91"><span class="toc-number">1.0.15.</span> <span class="toc-text">hashCode() 和 equals() 【4】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82-%E3%80%904%E3%80%91"><span class="toc-number">1.0.16.</span> <span class="toc-text">重载和重写的区别。 【4】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%82%E3%80%901%E3%80%91"><span class="toc-number">1.0.17.</span> <span class="toc-text">深拷贝和浅拷贝。【1】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%E3%80%903%E3%80%91"><span class="toc-number">1.0.18.</span> <span class="toc-text">面向对象和面向过程的区别。【3】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82%E5%B9%B6%E8%A7%A3%E9%87%8A%E8%BF%99%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%82%E3%80%903%E3%80%91"><span class="toc-number">1.0.19.</span> <span class="toc-text">面向对象三大特性是什么。并解释这三大特性。【3】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82-%E3%80%904%E3%80%91"><span class="toc-number">1.0.20.</span> <span class="toc-text">String、StringBuffer 和 StringBuilder 的区别。 【4】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E3%80%903%E3%80%91"><span class="toc-number">1.0.21.</span> <span class="toc-text">异常【3】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%E3%80%905%E3%80%91"><span class="toc-number">1.0.22.</span> <span class="toc-text">进程和线程的区别。【5】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82%E3%80%904%E3%80%91"><span class="toc-number">1.0.23.</span> <span class="toc-text">创建线程的方式。【4】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">1.0.24.</span> <span class="toc-text">线程的生命周期？几种状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E3%80%81wait-%E3%80%81join-%E3%80%81yield-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.25.</span> <span class="toc-text">sleep()、wait()、join()、yield()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E3%80%905%E3%80%91"><span class="toc-number">1.0.26.</span> <span class="toc-text">什么是死锁，死锁如何产生，如何避免【5】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.0.27.</span> <span class="toc-text">线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E3%80%82%E3%80%905%E3%80%91"><span class="toc-number">1.0.28.</span> <span class="toc-text">synchronized 锁升级流程。【5】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%905%E3%80%91"><span class="toc-number">1.0.29.</span> <span class="toc-text">volatile 关键字【5】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%905%E3%80%91"><span class="toc-number">1.0.30.</span> <span class="toc-text">乐观锁和悲观锁的区别【5】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E3%80%904%E3%80%91"><span class="toc-number">1.0.31.</span> <span class="toc-text">ThreadLocal【4】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%905%E3%80%91"><span class="toc-number">1.0.32.</span> <span class="toc-text">线程池【5】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E5%92%8C-AQS%E3%80%82%E3%80%904%E3%80%91"><span class="toc-number">1.0.33.</span> <span class="toc-text">ReentrantLock 和 AQS。【4】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="toc-number">1.0.34.</span> <span class="toc-text">JVM怎么判断哪些对象可以回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferCache"><span class="toc-number">1.0.35.</span> <span class="toc-text">BufferCache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">2.</span> <span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA%E3%80%81BASE%E7%90%86%E8%AE%BA"><span class="toc-number">3.1.</span> <span class="toc-text">CAP理论、BASE理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">负载均衡算法、类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CSession%E5%85%B1%E4%BA%AB"><span class="toc-number">3.3.</span> <span class="toc-text">如何进行Session共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E3%80%81RMI%EF%BC%88RPC%E7%9A%84java%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">RPC、RMI（RPC的java实现版本）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.</span> <span class="toc-text">分布式事务解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">3.6.</span> <span class="toc-text">接口的幂等性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Zookeeper%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">Zookeeper——分布式协调服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ZAB%E5%8D%8F%E8%AE%AE%EF%BC%88zk%E4%B8%93%E7%94%A8%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">ZAB协议（zk专用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zk%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">zk的数据模型和节点类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zk%E7%9A%84%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1%E3%80%81%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E3%80%81%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.3.</span> <span class="toc-text">zk的命名服务、配置管理、集群管理——三种使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zk%E4%B8%8Eeureka%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88CAP%E7%90%86%E8%AE%BA%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">zk与eureka的区别（CAP理论）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/18/Spring/" title="Spring"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring"/></a><div class="content"><a class="title" href="/2023/04/18/Spring/" title="Spring">Spring</a><time datetime="2023-04-18T03:27:49.000Z" title="Created 2023-04-18 11:27:49">2023-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/01/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis学习笔记"/></a><div class="content"><a class="title" href="/2023/04/01/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记">Redis学习笔记</a><time datetime="2023-04-01T03:27:41.000Z" title="Created 2023-04-01 11:27:41">2023-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/18/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/" title="算法题解题思路"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法题解题思路"/></a><div class="content"><a class="title" href="/2023/01/18/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/" title="算法题解题思路">算法题解题思路</a><time datetime="2023-01-18T08:43:39.000Z" title="Created 2023-01-18 16:43:39">2023-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" title="面试八股"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试八股"/></a><div class="content"><a class="title" href="/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" title="面试八股">面试八股</a><time datetime="2023-01-14T07:27:59.000Z" title="Created 2023-01-14 15:27:59">2023-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/13/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="MySQL学习笔记（一）"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL学习笔记（一）"/></a><div class="content"><a class="title" href="/2023/01/13/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" title="MySQL学习笔记（一）">MySQL学习笔记（一）</a><time datetime="2023-01-13T03:27:23.000Z" title="Created 2023-01-13 11:27:23">2023-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> LLoyyj</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">开心就好<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7427714271" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax defer src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>