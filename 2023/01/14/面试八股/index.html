<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试八股 | LLoyyj's blog</title><meta name="keywords" content="java,八股,面试"><meta name="author" content="LLoyyj"><meta name="copyright" content="LLoyyj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一星：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。 二星：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。 三星：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。 四星：面试高频考点。 五星：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问  这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试八股">
<meta property="og:url" content="http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="LLoyyj&#39;s blog">
<meta property="og:description" content="一星：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。 二星：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。 三星：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。 四星：面试高频考点。 五星：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问  这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg">
<meta property="article:published_time" content="2023-01-14T07:27:59.000Z">
<meta property="article:modified_time" content="2023-03-15T03:45:36.157Z">
<meta property="article:author" content="LLoyyj">
<meta property="article:tag" content="java">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/01/11/x4cowVP16vkygHB.png"><link rel="canonical" href="http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#5F9EA0&quot;,&quot;paginator&quot;:&quot;#B0E0E6&quot;,&quot;button_hover&quot;:&quot;#DED3CD&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;,&quot;scrollbar_color&quot;:&quot;#49b1f5&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: LLoyyj","link":"Link: ","source":"Source: LLoyyj's blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-03-15 11:45:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://s2.loli.net/2023/01/11/1NsbGvmfukWXBQM.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LLoyyj's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-14T07:27:59.000Z" title="Created 2023-01-14 15:27:59">2023-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-15T03:45:36.157Z" title="Updated 2023-03-15 11:45:36">2023-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">22.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>68min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>一星：面试中不常问到，如果面试官问到尽量能答出来，答不出来也没关系。</p>
<p>二星：面试中不常问到，但是如果面试官问到的话，答不出来对你的印象会减分。</p>
<p>三星：面试中会问到，答不出来面试有点悬。面试官会惊讶为什么你这也不会。</p>
<p>四星：面试高频考点。</p>
<p>五星：面试超高频考点。四星考点和五星考点是参加十场面试，至少能有五场面试问</p>
</blockquote>
<p>这些的。大家在准备面试过程中尽量把这些知识点的回答条理梳理清楚，面试官一问就开背。</p>
<blockquote>
<p>1.Java 语言的特点（如果你简历上有提到 C++ 可能还会问你 Java 和 C++ 的区别）。【⭐⭐】</p>
</blockquote>
<blockquote>
<p>2.比较 JVM 和 JDK 以及 JRE 。【⭐⭐】</p>
</blockquote>
<blockquote>
<p>3.为什么说 Java 语言“解释与编译并存”。【⭐⭐】</p>
</blockquote>
<blockquote>
<p>4.Java 基本类型有哪几种，各占多少位？【⭐⭐】</p>
</blockquote>
<blockquote>
<p>5.Java 泛型，类型擦除。【⭐】</p>
</blockquote>
<blockquote>
<p>6.&#x3D;&#x3D; 和 equals() 的区别。【⭐⭐⭐】</p>
</blockquote>
<blockquote>
<p>final</p>
</blockquote>
<ul>
<li>修饰类——类不可被继承</li>
<li>修饰方法——方法不可以被子类覆盖，但是可以重载</li>
<li>修饰变量——变量一旦被赋值就不可以更改值<ul>
<li>成员变量：<ul>
<li>类变量（static修饰）——在静态代码块中指定初始值 &#x2F; 声明时指定初始值</li>
<li>成员变量 —— 非静态初始化块、声明变量、构造器中执行初始值</li>
</ul>
</li>
<li>局部变量：在使用变量前赋值，但不允许第二次赋值<ul>
<li>基本数据类型：一旦初始化后不可以更改</li>
<li>引用类型：对其初始化后不可以在指向另一个对象，但引用的值是可变的</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>局部内部类和匿名内部类只能访问局部final变量？</p>
</blockquote>
<p>​	程序编译的时候会形成两个.class文件，除了本类还有内部类，但内部类和外部类同级别，并不会因为定义在方法中就会随着方法销毁。为了保证内部类可以在方法销毁后也可以访问局部变量，会将局部变量复制一份作为内部类的成员变量，但为了保证数据的一致性，将局部变量设置为final，，对他初始化后就不允许再修改，使得局部变量和内部类建立的拷贝保持一致。</p>
<blockquote>
<p>接口和抽象类的区别</p>
</blockquote>
<ul>
<li>抽象类里除了抽象方法也可以有普通成员函数，而接口中只能存在public abstract方法</li>
<li>抽象类中的成员变量可以是各种类型的，但接口中只能存在public static final类型的</li>
<li>抽象类只能继承一个，接口可以实现多个</li>
<li>抽象类是 is a 的关系（代码复用），接口是 like a 的关系（对类的行为进行约束）</li>
</ul>
<blockquote>
<p>7.hashCode() 和 equals() 【⭐⭐⭐⭐】</p>
</blockquote>
<p>这个问题经常问，面试官经常问为什么重写 equals() 时要重写 hashCode() 方法？</p>
<p>这个问题经常结合着 HashSet 问。</p>
<blockquote>
<p>8.重载和重写的区别。 【⭐⭐⭐⭐】</p>
</blockquote>
<ul>
<li>重载：<ul>
<li>在同一个类中</li>
<li>方法名必须相同</li>
<li>参数列表必须不同 —— 个数不同 &#x2F; 参数类型不同 &#x2F; 顺序不同</li>
<li>返回值和访问修饰符可以不同</li>
<li>发生在编译时<ul>
<li>编译器找不到匹配的参数时，会发生编译时错误 → 重载解析（overloading resolution）</li>
</ul>
</li>
</ul>
</li>
<li>重写：<ul>
<li>在父类与子类中</li>
<li>方法名、参数列表必须相同</li>
<li>返回值范围 &lt; 父类<ul>
<li>返回值重写时：<ul>
<li>void &#x2F; 基本数据类型：不可改</li>
<li>引用类型：可返回子类</li>
</ul>
</li>
</ul>
</li>
<li>抛出的异常范围 &lt;&#x3D; 父类</li>
<li>访问修饰符范围 &gt;&#x3D; 父类</li>
<li>父类方法访问修饰符为private时，不可以重写</li>
<li>发生在运行期</li>
</ul>
</li>
</ul>
<blockquote>
<p>9.深拷贝和浅拷贝。【⭐】</p>
</blockquote>
<blockquote>
<p>10.面向对象和面向过程的区别。【⭐⭐⭐】</p>
</blockquote>
<blockquote>
<p>11.成员变量与局部变量的区别。【⭐⭐⭐】</p>
</blockquote>
<blockquote>
<p>12.面向对象三大特性是什么。并解释这三大特性。【⭐⭐⭐】</p>
</blockquote>
<blockquote>
<p>13.String、StringBuffer 和 StringBuilder 的区别。 【⭐⭐⭐⭐】</p>
</blockquote>
<ul>
<li>String：<ul>
<li>保存字符串的数组由final、private修饰，不可变；</li>
<li>每次操作会生成新的对象，导致内存浪费；</li>
<li>Java9后底部数组由char[]改为byte[]，因为在latin-1编码下，byte占一个字节，char占两个字节，可以节省50%的内存空间。</li>
</ul>
</li>
<li>StringBuilder：<ul>
<li>在原对象操作</li>
<li>线程不安全</li>
<li>‘+’ ：等同于 StringBuilder.append().toString()<ul>
<li>在循环内使用+，会在每次循环创建一个StringBuilder对象，浪费内存</li>
</ul>
</li>
</ul>
</li>
<li>StringBuffer：在原对象上操作，线程安全（方法都是synchronized修饰）</li>
<li>性能：StringBuilder &gt; StringBuffer &gt; String</li>
<li>使用场景：经常需要改变字符串内容时使用后面两个，优先使用StringBuilder，多线程使用共享变量时使用StringBuffer。</li>
</ul>
<blockquote>
<p>14.异常。【⭐⭐⭐】</p>
</blockquote>
<p>不会问的特别细。经常的问法是异常可以分为哪几种，然后你答了可检查异常和不可检查异常以后，会让你举例可检查异常有哪些，不可检查有哪些。</p>
<p>然后异常的代码要会写，有一场字节的面试，直接让我写一个把异常捕获了然后抛出去的代码。</p>
<blockquote>
<p>15.序列化和反序列化【⭐⭐】</p>
</blockquote>
<blockquote>
<p>16.List、Set、 Map 的区别。【⭐⭐】</p>
</blockquote>
<ul>
<li>List<ul>
<li>有序、可重复的</li>
<li>可以用Iterator取出所有元素，逐一遍历 &#x2F; get(index)方法取出元素</li>
<li>ArrayList：<ul>
<li>Object[]存储，动态数组，连续内存存储，适用于频繁的查找工作</li>
<li>线程不安全</li>
<li>插入操作：<ul>
<li>指定位置i——O(n-i)</li>
<li>末尾——O(1)</li>
</ul>
</li>
<li>会在末尾预留一些空间 —— 占有内存空间</li>
<li>扩容机制：新建数组，复制数据到新数组</li>
<li>实现RAndomAccess接口，支持随机访问</li>
</ul>
</li>
<li>Vector：<ul>
<li>Object[]存储</li>
<li>线程安全</li>
</ul>
</li>
<li>LinkedList<ul>
<li>底层使用双向链表存储（JDK1.7取消使用双向循环链表）</li>
<li>线程不安全</li>
<li>插入操作：<ul>
<li>内部维护了一个node内部类，插入是会创建node对象，大量插入时性能消耗较大</li>
<li>指定位置i —— O(n)</li>
<li>末尾 —— O(1)</li>
</ul>
</li>
<li>遍历时使用Iterator而不是for循环<ul>
<li>每次for循环通过get(i)去取元素时都要重新遍历list，性能消耗极大</li>
</ul>
</li>
<li>indexOf()返回元素索引也会遍历整个list，性能消耗极大</li>
<li>每个元素都要消耗更多空间</li>
</ul>
</li>
</ul>
</li>
<li>Set<ul>
<li>无序、不可重复的</li>
<li>只能用Iterator取出所有元素，逐一遍历</li>
<li>HashSet<ul>
<li>保证元素唯一，线程不安全</li>
<li>底层数据结构为HashMap(但仅存储对象)</li>
<li>使用场景：不需保证元素插入和取出顺序时</li>
</ul>
</li>
<li>LinkedHashSet<ul>
<li>保证元素唯一，线程不安全</li>
<li>底层数据结构为链表+哈希表</li>
<li>使用场景：保证元素满足FIFO顺序时</li>
</ul>
</li>
<li>TreeSet<ul>
<li>保证元素唯一，线程不安全</li>
<li>底层数据结构为红黑树</li>
<li>使用场景：对元素自定义排序规则时</li>
</ul>
</li>
</ul>
</li>
<li>Map<ul>
<li>HashMap</li>
<li>Hashtable</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
<blockquote>
<p>17.「ArrayList 和 LinkedList 的区别。」【⭐⭐⭐⭐】</p>
</blockquote>
<p>答清楚每个分别采用什么数据结构，对比相应的优点和缺点。</p>
<blockquote>
<p>18.「HashMap、HashTable、以及 ConcurrentHashMap 的区别。」【⭐⭐⭐⭐⭐】</p>
</blockquote>
<p>现在面试的超高频考点。当面试官问到这个问题的时候，展现你背面试八股文能力的机会来了。</p>
<p>你可以展开去讲在 Java7 和 Java8 中 HashMap 分别采用什么数据结构，为什么 Java8 把之前的头插法改成了尾插法，怎样实现扩容，为什么负载因子是 0.75，为什么要用红黑树等等一系列的东西。只要面试官不打断我，我在这个知识点上能背到面试官下班。我最近也准备写一篇文章，详述上述知识点。</p>
<blockquote>
<p>19.进程和线程的区别。【⭐⭐⭐⭐⭐】</p>
</blockquote>
<p>这是一个超高频考点，面试回答时别一句一个进程包含很多线程就没了。</p>
<p>要答清楚什么是线程什么是进程，线程和进程各自的运行状态、线程的通信方式和进程的通信方式。</p>
<blockquote>
<p>20.创建线程的方式。【⭐⭐⭐⭐】</p>
</blockquote>
<p>不仅要把创建线程的方式记熟、记住各种方式的优缺点，还要能写出代码来。有的面试官是会让你写代码创建两个线程然后执行一些操作的，比如两个线程交替输出数字。</p>
<blockquote>
<p>线程的生命周期？几种状态？</p>
</blockquote>
<ul>
<li>创建状态 —— 新建线程对象</li>
<li>就绪状态 —— 调用该对象的start()后，变成可运行状态，等待获取CPU的使用权</li>
<li>运行状态 —— 就绪状态的线程获得了使用权，执行程序代码</li>
<li>阻塞状态 —— 线程由于某些原因放弃了CPU使用权，暂时停止运行直到线程重新进入就绪状态<ul>
<li>等待阻塞：wait()方法，释放所有资源（包括锁），等待notify()唤醒</li>
<li>同步阻塞：运行的线程未获取到同步锁，JVM将其放入锁池</li>
<li>其他阻塞：执行sleep() &#x2F; join()方法 &#x2F; 发出IO请求，JVM将其置为阻塞状态</li>
</ul>
</li>
<li>死亡状态 —— 线程执行完毕 &#x2F; 因异常退出了run()方法，线程结束生命周期</li>
</ul>
<blockquote>
<p>sleep()、wait()、join()、yield()的区别</p>
</blockquote>
<ul>
<li>join() ：线程A调用join方法后，使调用线程A的线程B进入阻塞状态，直到线程A结束或中断</li>
<li>yield() ：执行后线程进入就绪状态，暂时让出CPU执行权，等待分配CPU使用权</li>
<li>sleep() ：会让出CPU执行时间并且强制上下文切换 —— 用于当前线程休眠 &#x2F; 轮询暂停操作</li>
<li>wait() ：用于多线程之间的通信</li>
</ul>
<blockquote>
<p>21.什么是死锁，死锁如何产生，死锁如何避免。【⭐⭐⭐⭐⭐】</p>
</blockquote>
<p>超高频问题，几乎大厂的一面和二面都会问到。</p>
<blockquote>
<p>线程安全？</p>
</blockquote>
<ul>
<li>线程安全指的是内存安全，堆是共享内存，可以被所有线程访问</li>
<li>堆是进程线程共有的空间，分为全局堆和局部堆。全局堆是没有分配的空间，局部堆是用户分配的空间。<ul>
<li>堆在操作系统对进程初始化的时候创建（虚拟机启动时），唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</li>
<li>运行过程中可以向系统要额外的堆，但是用完了要还给操作系统，否则就是内存泄露</li>
</ul>
</li>
<li>栈是线程独有的，所以是线程安全的，是保存其运行状态的局部自动变量的<ul>
<li>在线程开始时初始化</li>
<li>操作系统在切换线程的时候会自动切换栈</li>
</ul>
</li>
</ul>
<blockquote>
<p>22.synchronized 锁升级流程。【⭐⭐⭐⭐⭐】</p>
</blockquote>
<p>这又是面试八股文的一大考点，锁升级流程记清楚。</p>
<blockquote>
<p>23.volatile 关键字。【⭐⭐⭐⭐⭐】</p>
</blockquote>
<p>对比和 synchronized 的区别。</p>
<blockquote>
<p>24.乐观锁和悲观锁的区别。【⭐⭐⭐⭐⭐】</p>
</blockquote>
<blockquote>
<p>25.ThreadLocal。【⭐⭐⭐⭐】</p>
</blockquote>
<ul>
<li>使用场景：<ul>
<li>在对象进行跨层传递时，使用参数列表一层一层传较为繁琐，使用ThreadLocal可以避免多次传递，存储在线程的ThreadLocalMap（线程本地变量）中，打破层次间的约束</li>
<li>线程私有的，所以不存在线程安全性问题，线程间数据隔离</li>
<li>进行事务操作，用于存储线程事务信息</li>
<li>数据库连接，session会话管理</li>
</ul>
</li>
<li>ThreadLocal内存泄漏：<ul>
<li>不在会被使用的对象或者变量占用的内存不可回收——内存泄漏  ！&#x3D; OOM（内存不够）</li>
<li>强引用：new &#x2F; 反射创建的对象都是强引用，这样不会被垃圾回收器回收<ul>
<li>内存空间不足时，JVM会抛出OutOfMemoryError错误，也不会回收这种对象</li>
<li>显式赋值为null时，表明可以进行回收</li>
</ul>
</li>
<li>弱引用：<ul>
<li>JVM无论内存够不够，都会回收弱引用的对象</li>
<li>java.lang.ref.WeakReference类的对象</li>
<li>可以在缓存中使用弱引用，缓存中回收也没关系，可以重新建立</li>
</ul>
</li>
<li>根源：ThreadLocalMap的生命周期和Thread一样长，如果没有手动删除对应key就会导致内存泄露，而不是因为弱引用。</li>
<li>正确的使用：<ul>
<li>每次使用完ThreadLocal都调用remove()方法清除数据</li>
<li>将ThreadLocal遍历定义为private static ，这样就一直存在ThreadLocal的强引用，也能保证任何时候都能通过ThreadLocal的弱引用访问的Entry的值，进而清除掉</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>26.线程池。【⭐⭐⭐⭐⭐】</p>
</blockquote>
<p>超高频考点。需要答出线程池有哪几种，各种线程池的优缺点，线程池的重要参数、线程池的执行流程、线程池的饱和策略、如何设置线程池的大小等等。这里也能背十几分钟。</p>
<blockquote>
<p>27.ReentrantLock 和 AQS。【⭐⭐⭐⭐】</p>
</blockquote>
<p>其实我在面试的时候对这里不是很熟，我面试的时候尽量不提到这里，也苟过去了。大家如果时间充足的话还是把这块好好理解一下。如果这里理解透彻了，也能在这里和面试官聊很久。</p>
<blockquote>
<p>如何实现一个IOC容器</p>
</blockquote>
<ol>
<li>配置文件中指定需要扫描的包的路径</li>
<li>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注解</li>
<li>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息以及文件夹信息，将当前路径下所有的字节码文件添加到set集合</li>
<li>反射、确定需要交给IOC管理的类</li>
<li>对需要注入的类进行依赖注入</li>
</ol>
<blockquote>
<p>JVM怎么判断哪些对象可以回收</p>
</blockquote>
<ul>
<li>可达性分析：从GCRoots 开始向下搜索，搜索走过的路径称为引用链。当一个对象到root没有任何引用链相连时，证明此对象不可用，虚拟机判断为可回收对象，进行一次标记，两次标记后直接回收。</li>
</ul>
<h1 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h3><ul>
<li><p>是一个轻量级的控制反转（IOC）和面向切面(AOP)的容器框架</p>
</li>
<li><p>容器框架 —— 装javabean（java对象）—— 包含并管理应用对象（Bean）的配置和生命周期</p>
</li>
<li><p>中间层框架 —— 起连接作用  ——将简单的组件、配置组合成为复杂的应用</p>
</li>
<li><p>从大小开销两方面都是轻量级</p>
</li>
<li><p>通过控制反转（IOC）的技术达到松耦合的目的</p>
</li>
<li><p>提供了面向切面的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发</p>
</li>
</ul>
<h3 id="AOP面向切面、OOP面向对象"><a href="#AOP面向切面、OOP面向对象" class="headerlink" title="AOP面向切面、OOP面向对象"></a>AOP面向切面、OOP面向对象</h3><p>系统的不同功能组件都需要例如日志、事务管理、安全这样的核心公共服务（横切关注点）</p>
<ul>
<li>若使用OOP则需要为每个核心业务对象定义公共服务对象，会导致大量代码的重复，不利于模块的复用</li>
<li>AOP将程序中的交叉业务逻辑封装成一个切面，注入到目标对象中</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><ul>
<li>容器概念：存放各种对象（xml中配置的bean节点、@repository、@service、@controller、@component）的map。<ul>
<li>在项目启动时会读取配置文件的里面的bean，根据全限定类名使用反射创建对象放到map里；</li>
<li>扫描到打上注解的类还是通过反射创建对象放到map里</li>
<li>在代码中需要使用map中的对象时，通过DI注入（@Aurowired、@Resource等注解，xml里bean节点内的ref属性）</li>
<li>项目启动时会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入（id就是对象名）</li>
</ul>
</li>
<li>控制反转<ul>
<li>没有引入IOC之前，对象A依赖对象B需要主动创建初始化对象B；引入IOC容器后，使对象AB都依赖于IOC容器，IOC容器在对象A需要依赖对象B时主动创建注入到对象A中。</li>
<li>全部对象的控制权都交给IOC容器，成为了整个系统的核心，like a粘合剂，将系统中所有的对象粘合在一起发挥作用。</li>
</ul>
</li>
<li>依赖注入：实现IOC容器的方法——IOC容器在运行期间，动态的将某种依赖关系注入到对象中</li>
</ul>
<h3 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h3><ul>
<li>BeanFactory：<ul>
<li>延迟加载来注入Bean，使用某个Bean的时候才会加载实例化，这样就不能发现一些存在的Spring配置问题，直到第一次调用才会抛出异常</li>
<li>通常以编程的方式被创建</li>
<li>支持BeanPostProcessor、BeanFactoryPostProcessor，需要手动注册</li>
</ul>
</li>
<li>ApplicationContext：<ul>
<li>在容器启动时一次性创建所有的Bean，可以发现Spring存在的配置错误，有利于检查所依赖属性是否注入。</li>
<li>在启动后预加载所有的单实例Bean，需要的时候不用等待直接用。</li>
<li>不足：占用内存空间，当应用程序配置bean较多时程序启动较慢</li>
<li>除了以编程的方式被创建，还可以以声明的方式创建，如使用ContextLoader</li>
<li>支持BeanPostProcessor、BeanFactoryPostProcessor，自动注册</li>
</ul>
</li>
</ul>
<h3 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h3><ol>
<li>解析类得到BeanDefinition</li>
<li>如果有多个构造方法，则要推断构造方法</li>
<li>确定好构造方法后，进行实例化得到一个对象</li>
<li>对对象中加了@Autowired注解的属性进行属性填充</li>
<li>回调Aware方法，比如BeanNameAware、BeanFactoryAware</li>
<li>调用BeanPostProcessor初始化前的方法</li>
<li>调用初始化方法</li>
<li>调用BeanPostProcessor初始化后的方法，这里进行AOP动态代理</li>
<li>如果创建的bean是单例的则会放入单例池</li>
<li>使用bean</li>
<li>Spring容器关闭时调用DisposableBean中destory()方法销毁</li>
</ol>
<h3 id="Spring框架中用到了那些设计模式"><a href="#Spring框架中用到了那些设计模式" class="headerlink" title="Spring框架中用到了那些设计模式"></a>Spring框架中用到了那些设计模式</h3><ul>
<li>简单工厂（不是23种之一）：由一个工厂类根据传入的参数，动态决定创建那个产品类<ul>
<li>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识，getBean()获得Bean对象，根据情况来定实在传入参数后创建还是前创建</li>
</ul>
</li>
<li>工厂方法：</li>
<li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</li>
<li>适配器模式：</li>
<li>装饰器模式：动态的给一个对象添加一些额外的职责<ul>
<li>Spring用到的包装器模式在在类名上有两种体现，分别是类名中含有Wrappper &#x2F; Decorator（Decorator模式相比生成子类更为灵活）</li>
</ul>
</li>
<li>动态代理：</li>
<li>观察者模式：</li>
<li>策略模式：</li>
</ul>
<h3 id="Spring事务的实现方式-x2F-原理-x2F-隔离级别"><a href="#Spring事务的实现方式-x2F-原理-x2F-隔离级别" class="headerlink" title="Spring事务的实现方式 &#x2F; 原理 &#x2F; 隔离级别"></a>Spring事务的实现方式 &#x2F; 原理 &#x2F; 隔离级别</h3><ul>
<li>使用spring框架时有两种使用事务的方式 —— spring是基于数据库中的事务进行了扩展，以及提供了一些让程序员更加方便操作事务的方式<ul>
<li>编程式 ： 调用api、rollback方法</li>
<li>申明式 ： 在方法上加@Transactional注解，就可以开启事务，这个方法中所有的sql都在一个事务中执行，统一成功或失败<ul>
<li>方法上加@Transactional注解后，spring会基于这个类生成一个代理对象，将其作为bean，当使用这个代理对象的方法时，如果方法上有@Transactional注解，代理逻辑会将事务的自动提交设置为false，再去执行原本的业务逻辑方法，如果没有出现异常则提交事务，出现了异常便将事务回滚</li>
<li>可以自定义异常回滚，使用@Transactional中的rollbackFor属性，配置对哪些抛出的异常进行回滚（catch后不能算抛出异常），默认对RuntimeException和Error进行回滚</li>
</ul>
</li>
</ul>
</li>
<li>spring事务的隔离级别 &#x3D; 数据库的隔离级别：外加一个默认级别<ul>
<li>read uncommitted（未提交读）</li>
<li>read committed（提交读，不可重复读）（Oracle数据库的默认级别）</li>
<li>repeatable read（可重复读）（Mysql的默认级别）</li>
<li>serializable（可串行化）</li>
<li>隔离级别以spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库</li>
</ul>
</li>
</ul>
<h3 id="spring事务传播机制"><a href="#spring事务传播机制" class="headerlink" title="spring事务传播机制"></a>spring事务传播机制</h3><p>多个事务方法相互调用时，事务如何在这些方法间传播</p>
<ul>
<li>REQUIRED(默认)：被调用方出现异常时，无论调用方是否catch都会回滚</li>
<li>SUPPORTS</li>
<li>MANDATORY</li>
<li>REQUIRES_NEW：原有事务回滚，不会影响新事务</li>
<li>NOT_SUPPORTED</li>
<li>NEVER</li>
<li>NESTED：父事务回滚子事务也会回滚，子事务回滚父事务不一定回滚（可能catch了异常）</li>
</ul>
<h3 id="Spring事务失效-——-原理是AOP进行了切面增强，事务失效原因是AOP失效"><a href="#Spring事务失效-——-原理是AOP进行了切面增强，事务失效原因是AOP失效" class="headerlink" title="Spring事务失效 —— 原理是AOP进行了切面增强，事务失效原因是AOP失效"></a>Spring事务失效 —— 原理是AOP进行了切面增强，事务失效原因是AOP失效</h3><ul>
<li>发生自调用，类里面使用this.调用本身的方法时，不是由代理bean调用，而是类本身调用<ul>
<li>解决方法：使用注入的对象调用本类方法</li>
</ul>
</li>
<li>方法只能是public的，如果非要用在非public的方法上，只能改变代理方式</li>
<li>数据库不支持事务</li>
<li>没有被spring管理（没有加入IOC容器、没有加@Service等注解）</li>
<li>异常被吃掉，事务不会回滚  &#x2F;  抛出的异常没有定义，默认为RuntimeException</li>
</ul>
<h3 id="bean的自动装配"><a href="#bean的自动装配" class="headerlink" title="bean的自动装配"></a>bean的自动装配</h3><ul>
<li>autowire &#x3D; “ “<ul>
<li>byName 属性名</li>
<li>byType 属性类</li>
<li>constructor 构造器的参数类</li>
<li>autodetect 有默认构造器则按constructor 无则byType</li>
</ul>
</li>
<li>AutoWired自动装配</li>
</ul>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot、SpringMVC、Spring"><a href="#SpringBoot、SpringMVC、Spring" class="headerlink" title="SpringBoot、SpringMVC、Spring"></a>SpringBoot、SpringMVC、Spring</h3><ul>
<li>spring：IOC容器，管理Bean，使用依赖注入实现控制反转，降低耦合，很方便的整合各种框架，提供AOP机制避免OOP代码重复的问题，更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等</li>
<li>springMVC：spring对web框架的解决方案。提供了一个总的前端控制器用来接收请求，然后定义了一套路由策略（url到handler的映射）及适配执行handler，再将handler结果使用视图解析器解析成视图展现给前端<ul>
<li>工作流程：<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li>
<li>处理器映射器找到具体的处理器（可根据xml配置、注解进行查找），生成处理器以及处理器拦截器一并返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器</li>
<li>HandlerAdapter经过适配调用具体的处理器（Controller）</li>
<li>Controller执行完成返回ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器</li>
<li>ViewResolver解析后返回具体View</li>
<li>DispatcherServlet根据view进行渲染视图（即将模型数据填充至视图中）</li>
<li>DispatcherServlet响应用户</li>
</ol>
</li>
<li>主要组件：（Handler相当于请求的方法）<ul>
<li>HandlerMapping —— 根据url查找handler</li>
<li>HandlerAdapter ——请求与handler方法适配</li>
<li>HandlerExceptionResolver</li>
<li>ViewResolver —— 使用jstl解析成view</li>
<li>RequestToViewNameTranslator</li>
<li>LocaleResolver</li>
<li>ThemeResolver</li>
<li>MultipartResolver</li>
<li>FlashMapManager</li>
</ul>
</li>
</ul>
</li>
<li>SpringBoot：spring提供的一个快速开发工具包，更快速的开发spring+springMVC应用，简化了配置，整合了一系列的解决方案（starter机制）、redis、mongodb、es，可以开箱即用<ul>
<li>自动配置原理：@Import + @Configuration（+@Bean） + Spring spi（读META-INF&#x2F;spring.factories）<ul>
<li>自动配置类（如：Mybatis）由各个starter提供，使用@Configuration+@Bean定义配置类，放到META-INF&#x2F;spring.factories下</li>
<li>使用 Spring spi扫描META-INF&#x2F;spring.factories下的配置类</li>
<li>使用@Import导入自动配置类</li>
</ul>
</li>
<li>starter：（spring+springMVC开发时，要引用mybatis等框架需要到xml中定义需要的bean）（springboot的starter机制避免了这种需要由程序员手动配置的繁复工作）<ul>
<li>定义一个starter的jar包</li>
<li>写一个@Configuration配置类，将需要的bean定义在里面</li>
<li>在starter包的META-INF&#x2F;spring.factories中写入该配置类</li>
<li>springboot会按照约定加载该配置类</li>
<li>开发人员只需将starter包依赖进应用，进行相应的属性配置（使用默认配置时不需要配置），就可以直接进行代码开发</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="Mybatis-和-Hibernate"><a href="#Mybatis-和-Hibernate" class="headerlink" title="Mybatis 和 Hibernate"></a>Mybatis 和 Hibernate</h3><ul>
<li><p>操作数据库层的框架</p>
</li>
<li><p>ORM对象关系映射——java对象与db映射（mybatis没有维护这个映射关系）</p>
</li>
<li><p>开发速度：</p>
<ul>
<li><p>学习成本：hibernate &gt; mybatis</p>
</li>
<li><p>项目结构：</p>
<ul>
<li>简单的增删改查：Hibernate——使用封装好的sql语句</li>
<li>大型项目：mybatis快，开发量大，但语句管理比较方便</li>
</ul>
</li>
</ul>
</li>
<li><p>开发工作量：</p>
<ul>
<li>有相应代码生成工具，生成基本的DAO方法</li>
<li>高级查询时hibernate无需关心sql的生成与结果映射，可以更专注于业务流程</li>
</ul>
</li>
<li><p>sql优化：</p>
<ul>
<li>mybatis可以手动调整</li>
</ul>
</li>
<li><p>对象管理：</p>
<ul>
<li>hibernate：对象状态管理</li>
</ul>
</li>
<li><p>缓存机制：</p>
<ul>
<li>都可以实现自己的缓存或使用第三方缓存，创建适配器完全覆盖缓存</li>
<li>mybatis使用二级缓存需要小心</li>
</ul>
</li>
<li><p>hibernate数据库无关性好，mybatis工作量较大</p>
</li>
</ul>
<h3 id="和"><a href="#和" class="headerlink" title="#{} 和${}"></a>#{} 和${}</h3><ul>
<li>#{}<ul>
<li>预编译，是占位符</li>
<li>mybatis处理时会替换成？号，调用preparedstatement赋值</li>
<li>变量替换在DBMS中、变量替换后，对应变量自动加上单引号</li>
<li>可以有效防止SQL注入，提高系统安全性</li>
</ul>
</li>
<li>${}<ul>
<li>字符串替换，是拼接符</li>
<li>mybatis处理时会替换成变量的值，调用statement赋值</li>
<li>变量替换在DBMS外、变量替换后，对应变量不会加上单引号</li>
</ul>
</li>
</ul>
<h3 id="Mybatis插件运行原理，如何编写一个插件"><a href="#Mybatis插件运行原理，如何编写一个插件" class="headerlink" title="Mybatis插件运行原理，如何编写一个插件"></a>Mybatis插件运行原理，如何编写一个插件</h3><ul>
<li>只支持拦截ParameterHandler（参数数据类型转换工具）、ResultSetHandler（接收JDBC中的结果集）、StatementHandler（JDBC中的statement的封装，映射结果集）、Executor（生成sql语句，缓存的维护）四种接口的插件，使用JDK的动态代理，为需要拦截的接口生成代理对象以实现拦截功能</li>
<li>编写插件<ul>
<li>实现mybatis的interceptor接口并复写intercept()方法，</li>
<li>再给插件编写注解@Intercepts（指定拦截的方法以及方法的参数列表）、@component（Mybatis和spring整合时，需要将拦截器放入ioc容器中，拦截器才生效）&#x2F; 在配置文件中配置编写的插件</li>
<li>编写代码</li>
<li>调用invocation.proceed()执行原方法的业务逻辑</li>
</ul>
</li>
</ul>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="存储引擎：MyISAM-amp-InnoDB"><a href="#存储引擎：MyISAM-amp-InnoDB" class="headerlink" title="存储引擎：MyISAM&amp;InnoDB"></a>存储引擎：MyISAM&amp;InnoDB</h3><ul>
<li>InnoDB<ul>
<li>适合写操作，读写分离时·写库</li>
<li>支持ACID事务，支持事务的四种隔离级别</li>
<li>支持行级锁、外键约束——支持写并发</li>
<li>不存储表的总行数</li>
<li>存储在一个文件空间，也有可能为多个（聚簇索引）</li>
<li>主键索引采用聚簇索引，辅索引的数据域存储主键的值——从辅索引查找数据，要先通过辅索引找到主键值，在访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整</li>
</ul>
</li>
<li>MyISAM<ul>
<li>读写分离时·读库</li>
<li>不支持事务，每次查询都是原子的</li>
<li>支持表级锁，每次操作都是对整个表加锁</li>
<li>存储表的总行数</li>
<li>一个表有三个文件：索引文件、表结构文件、数据文件（非聚簇索引）</li>
<li>索引文件的数据域存储指向数据文件的指针</li>
<li>辅索引和主索引基本一致，但是辅索引不用保证唯一性</li>
</ul>
</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>快速的查找特定值的记录，避免查找操作时遍历整张表</li>
<li>原理：把无序的数据变成有序地查询<ul>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询时，先拿到倒排表内容，再拿出数据地址链，从而拿到具体数据</li>
</ul>
</li>
<li>数据机构：哈希表 &amp; B+树<ul>
<li>mysql中使用较多的有hash索引和B+树索引</li>
<li>innoDB默认实现索引为B+树</li>
<li>hash索引底层数据结构是哈希表，单条记录查询时，性能最快</li>
<li>其余大部分场景，建议选择B-Tree索引</li>
</ul>
</li>
<li>B+树：<ul>
<li>平衡多叉树——根节点到每个叶子节点的高度值查不超过1</li>
<li>同层级的节点间有指针相互链接</li>
<li>从根节点到叶子结点的搜索效率基本相当</li>
<li>基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率高</li>
<li>关键字检索效率比较平均，不像B树那样波动幅度大</li>
</ul>
</li>
<li>哈希索引<ul>
<li>键值换算成哈希值，对应记录存储的地址</li>
<li>键值唯一时，等值查询哈希索引很快</li>
<li>范围查询，哈希表无排序</li>
<li>不能利用索引完成排序</li>
<li>不支持多列联合索引的最左匹配规则</li>
</ul>
</li>
<li>聚簇索引 &amp; 非聚簇索引<ul>
<li>都是B+树的数据结构（叶子节点才有数据，其余节点都是索引）</li>
<li>聚簇索引的叶子节点有索引+数据<ul>
<li>效率要高（非覆盖索引的情况下·要查询的字段不是索引的时候）</li>
<li>查询范围效率高，因为是按大小排序的，找到边界就行</li>
<li>适合用在排序的组合（本身为排序好的）</li>
</ul>
</li>
<li>非聚簇索引的叶子节点存放索引+数据行地址</li>
</ul>
</li>
<li>设计原则<ul>
<li>综：查询更快，占用内存空间更小<ol>
<li>出现在where子句的列或者是连接子句中指定的列，适合索引</li>
<li>基数较小的表，索引效果较差</li>
<li>使用短索引，索引也要占空间——如果对长字符串进行索引，应取前缀长度，节省索引空间，如果搜索词超过索引前缀长度，则是有索引排除不匹配的行，再检查其余行是否匹配（时间换空间）</li>
<li>不要过度索引，会降低写操作的性能——修改表内容时还要一并修改索引，索引列越多，索引更新或重构的时间越长，维护成本大</li>
<li>定义有外键的数据列一定要建立索引</li>
<li>更新频繁的字段 &#x2F; 不能有效区分数据列（性别等区分度低的字段）不适合建立索引</li>
<li>查询中很少涉及的列 &#x2F; 重复值较多的列 &#x2F; 定义为text、image、bit的数据类型的列不要建立索引</li>
<li>尽量扩展索引，不要新建索引</li>
</ol>
</li>
</ul>
</li>
<li>索引类型<ul>
<li>普通索引：允许被索引的数据列包含重复的值</li>
<li>唯一索引：不允许被索引的数据列包含重复的值，可以保证数据记录的唯一性</li>
<li>主键：特殊的唯一索引，聚簇索引</li>
<li>联合索引：索引可以覆盖多个数据列，如像INDEX（columnA，columnB）索引</li>
<li>全文索引：建立倒排索引，可以极大地提升检索效率，可以通过ALTER TABLE table_name ADD FULLTEXT(column);创建全文索引</li>
</ul>
</li>
<li>对数据库的性能的影响<ul>
<li>极大的提高数据的查询速度</li>
<li>可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
<li>会降低插入、删除、更新表的速度，因为在执行这些写操作时，h还要操作索引文件</li>
<li>索引要占物理空间，除了数据表占数据空间外，每个索引也要占空间，如果要建立聚簇索引，那需要的空间会更大，如果非聚簇索引很多，一旦聚簇索引改变，所有的非聚簇索引都会跟着变</li>
</ul>
</li>
</ul>
<h3 id="MySQL锁（可以显式加锁-x2F-自动加锁）"><a href="#MySQL锁（可以显式加锁-x2F-自动加锁）" class="headerlink" title="MySQL锁（可以显式加锁 &#x2F; 自动加锁）"></a>MySQL锁（可以显式加锁 &#x2F; 自动加锁）</h3><ul>
<li>基于属性分类：<ul>
<li>共享锁（share lock）—— 读锁 &#x2F; S锁<ul>
<li>一个事务为数据加上读锁后，其他事务只能对该数据加读锁，不能加写锁，直到所有的读锁释放后其他事务才能对其进行写锁加持</li>
<li>主要是为了支持并发的读取数据，读取的时候不支持修改数据，避免出现重复读的问题</li>
</ul>
</li>
<li>排他锁（exclusive lock）—— 写锁 &#x2F; X锁<ul>
<li>一个事务为数据加上写锁后，其他事务不能对该数据加任何锁，直到该锁释放后其他事务才能对其进行加锁</li>
<li>z主要是为了数据修改时，不允许其他人同时修改，也不允许其他人读取，避免出现脏数据和脏读的问题</li>
</ul>
</li>
</ul>
</li>
<li>基于锁的粒度分类：<ul>
<li>行级锁（InnoDB）：<ul>
<li>上锁的时候锁住表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录无法访问</li>
<li>粒度小、加锁比表锁麻烦</li>
<li>不容易冲突、相比表所支持的并发高，没有死锁</li>
</ul>
</li>
<li>表级锁（InnoDB \ MYisam）：<ul>
<li>上锁锁住整个表，下一个事务须待前一个事务释放锁后再进行访问</li>
<li>粒度大、加锁简单</li>
<li>容易冲突，有死锁</li>
</ul>
</li>
<li>页级锁（BDB引擎）：<ul>
<li>锁定粒度介于表锁和行锁间，表级锁速度快但冲突多，行级锁冲突少但速度慢，页级锁折中，一次锁定相邻的一组记录（可设置一页几条记录）</li>
<li>开销和加锁时间介于表锁和行锁之间，会出现死锁</li>
<li>锁定粒度介于表锁和行锁之间，并发度一般</li>
</ul>
</li>
<li>记录锁：<ul>
<li>行锁的一种，锁一条记录</li>
<li>精确条件命中，并且命中的条件字段是唯一索引</li>
<li>可以避免数据在查询的时候被修改的 重复读问题、也避免了在修改事务未提交前被其他事务读取的 脏读问题</li>
</ul>
</li>
<li>间隙锁<ul>
<li>行锁的一种，锁表的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则</li>
<li>只会出现在重复读的事务级别中</li>
</ul>
</li>
<li>临键锁（InnoDB的行锁默认算法）<ul>
<li>行锁的一种，记录所和间隙锁的结合，会把查询出来的记录锁住，也会把该范围查询内的所有间隙空间锁住，再把相邻的下一个区间锁住</li>
<li>范围查询并命中，查询命中了索引时触发</li>
<li>避免了范围查询时出现脏读、重复读、幻读的问题，加了临建锁后，在范围区间内部数据不允许修改和插入</li>
</ul>
</li>
</ul>
</li>
<li>基于锁的状态分布：意向共享锁、意向排他锁<ul>
<li>一种状态，告诉其他人是否有人对表里的行加了排他锁 &#x2F; 共享锁</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="MySQL执行计划"><a href="#MySQL执行计划" class="headerlink" title="MySQL执行计划"></a>MySQL执行计划</h3></blockquote>
<ul>
<li>执行计划就是sql执行查询的顺序，以及如何使用索引查询，返回的结果集的行数</li>
<li>EXPLAIN （sql语句）</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>越高表示优先级越高</td>
<td></td>
<td>表名</td>
<td></td>
<td>最好避免index和ALL</td>
<td>可能用到的索引值</td>
<td>索引值</td>
<td>使用到的索引值长度</td>
<td></td>
<td>匹配到了几行记录</td>
<td>目标行占匹配到的行记录的比率（100%最好）</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<h3 id="事务的基本特性-amp-隔离级别"><a href="#事务的基本特性-amp-隔离级别" class="headerlink" title="事务的基本特性&amp;隔离级别"></a>事务的基本特性&amp;隔离级别</h3></blockquote>
<ul>
<li>ACID<ul>
<li>原子性：一个事务中的操作要么全部成功，要么全部失败<ul>
<li>由undo log日志保证，记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li>
</ul>
</li>
<li>一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态<ul>
<li>有其他三大特性保证，程序代码要保证业务上的一致性</li>
</ul>
</li>
<li>隔离性：一个事务的修改在最终提交前，对其他事务是不可见的<ul>
<li>隔离级别：<ul>
<li>read uncommitted（读未提交）可能会读到其他事务未提交的数据——脏读</li>
<li>read committed（读已提交，不可重复读）（Oracle数据库的默认级别）</li>
<li>repeatable read（可重复读）（Mysql的默认级别）一个事务的两次查询数据不一致——幻读</li>
<li>serializable（可串行化）会给每一行读取的数据加锁，会导致大量超时和锁竞争问题</li>
</ul>
</li>
<li>MVCC保证隔离性<ul>
<li>多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁就不冲突了，不同的事务session会看到自己特定版本的数据，版本链</li>
<li>只在read committed、repeatable read两个级别下工作，其他两个级别和MVCC不兼容，read uncommitted总是读取最新的数据行，而不是符合当前事务版本的数据行，而serializable则会对所有读取的行加锁</li>
<li>聚簇索引记录中有两个必要的隐藏列——版本链<ul>
<li>trx_id：存储每次对聚簇索引记录进行修改的时候的事务id</li>
<li>roll_pointer：将记录的老版本写入undo日志中，roll_pointer存了一个指针，指向老版本（插入操作无）</li>
</ul>
</li>
<li>开始事务时创建readview维护当前活动事务的id，即未提交的事务id，排序生成一个数组，访问数据获取数据中的事务id（是事务id最大的记录），对比readview<ul>
<li>在左边——事务id小——已提交——可以访问</li>
<li>在右边 &#x2F; 中间—— readview生成之后出现 &#x2F; 当前活动的事务（未提交）——不可以访问——获取roll_pointer取上一版本重新对比</li>
</ul>
</li>
<li>read committed隔离级别下的事务在每次查询开始都会生成一个独立的readview，而repeatable read则在第一次读的时候生成readview，之后读都复用</li>
<li>通过版本链，实现多版本，可并发读写，写读</li>
</ul>
</li>
</ul>
</li>
<li>持久性：一旦事务提交，所作的修改就会永久的保存到数据库中<ul>
<li>由内存+redo log保证，mysql（InnoDB）修改数据同时在内存和redo log记录这次操作，宕机的时候可以存redo log恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="SQL耗时——慢查询优化"><a href="#SQL耗时——慢查询优化" class="headerlink" title="SQL耗时——慢查询优化"></a>SQL耗时——慢查询优化</h3></blockquote>
<ul>
<li>除了使用主键进行的查询，其他的都会在测试库上测试耗时，筛选出慢查询</li>
<li>原因：查询条件没有命中索引 &#x2F; load了不需要的数据列 &#x2F; 数据量太大</li>
<li>优化：<ol>
<li>分析语句，可能是查询了多余的行并且抛弃掉了 &#x2F; 加载了许多结果中不需要的列，对语句进行分析以及重写</li>
<li>分析语句的执行计划，获得索引的使用情况，修改语句或者索引，尽可能命中索引</li>
<li>优化已经无法进行，表的数据量太大，考虑进行横向或者纵向的分表。</li>
</ol>
</li>
</ul>
<blockquote>
<h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3></blockquote>
<ul>
<li><p>mysql主从复制是通过binlog保证，将主库所有的变更记录到日志中，从服务器执行的sql主服务器通过binlog获取再执行一遍以保证数据的持久性</p>
</li>
<li><p>主从复制有三个线程：</p>
<ul>
<li>log dump线程（master），当binlog有变动时，线程读取内容并且发送给从节点</li>
<li>I&#x2F;O线程（slave），接收binlog内容，并将其写入relay log（中继日志）</li>
<li>SQL线程（slave），读取relay log文件内容对数据更新</li>
</ul>
</li>
<li><p>主从节点使用binlog+position偏移量定位主从同步的位置，从节点会保存已收到的偏移量，如果节点发生宕机重启，则自动从position发起同步</p>
</li>
<li><p>mysql默认异步复制，可能会导致日志丢失</p>
<ul>
<li>全同步复制：待从库都执行完成后才返回，从库多时性能很低</li>
<li>半同步复制：从库写入日志后返回ACK确认给主库，主库至少收到一个确认就认为写操作完成</li>
</ul>
</li>
</ul>
<h1 id="Redis（单进程单线程）"><a href="#Redis（单进程单线程）" class="headerlink" title="Redis（单进程单线程）"></a>Redis（单进程单线程）</h1><h3 id="RDB-amp-AOF机制"><a href="#RDB-amp-AOF机制" class="headerlink" title="RDB &amp; AOF机制"></a>RDB &amp; AOF机制</h3><ul>
<li>RDB：Redis Database<ul>
<li>在指定时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储</li>
<li>优点：<ol>
<li>整个redis数据库将只包含一个文件dump.rdb，方便持久化</li>
<li>容灾性好，方便备份</li>
<li>性能最大化，fork子进程完成写操作，主进程继续执行命令。所以是IO最大化。保证了redis的高性能</li>
<li>相对于数据集大时，比AOF的启动效率更高</li>
</ol>
</li>
<li>缺点：<ol>
<li>数据安全性低，RDB时间隔一段时间进行持久化，若在中间间隔的时间redis发生故障，会发生数据丢失（所以rdb更适合数据要求不严谨的时候）</li>
<li>RDB通过fork子进程协助完成数据持久化工作，so如果数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是一秒钟</li>
</ol>
</li>
</ul>
</li>
<li>AOF：Append Only File<ul>
<li>以日志的形式记录服务器所处理的每一个写、删除操作（查询不会记录），以文本的方式记录，可以打开文件看到详细的操作记录</li>
<li>优点：<ol>
<li>数据安全，redis提供了三种同步策略（每秒同步、每修改同步、不同步）。每秒同步是异步完成的，效率很高，但一旦系统宕机，那么这一秒内修改的数据将会丢失；而每修改同步可以视为同步持久化，每次发生的数据变化都会被立即记录到磁盘中</li>
<li>append模式写文件，中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性的问题</li>
<li>AOF机制的rewrite模式，定期对AOF文件进行重写，合并操作，以达到压缩的目的</li>
</ol>
</li>
<li>缺点：<ol>
<li>AOF文件比RDB大，且恢复速度慢（全部重新操作一遍）</li>
<li>数据集大的时候，比RDB启动效率低</li>
<li>运行效率没有RDB高（因为追加）</li>
</ol>
</li>
</ul>
</li>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据，AOF比RDB安全也更大，但RDB性能更好，如果两个都配了会优先加载AOF</li>
</ul>
<h3 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h3><ul>
<li>惰性过期：访问时判断是否过期再进行清除——最大化节省CPU资源，但占内存</li>
<li>定时过期：给key设置过期时间，过期就删除（redis没用）</li>
<li>定期过期：每隔一段时间，扫描一定数量的数据库的expires字典（保存了所有设置了过期时间的key的过期时间数据，其中key是指向某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间）中一定数量的key，过期就清楚——通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果</li>
<li>redis中同时使用惰性过期和定期过期两种策略</li>
</ul>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><ul>
<li>Redis基于Reactor（响应）模式开发了网络事件处理器，这个处理器叫做文件事件处理器file event handler。这个文件事件处理器，它是单线程的，所以Redis 才叫做单线程的模型，它采用lO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了Redis 内部的线程模型的简单性。</li>
<li>文件事件处理器的结构包含4个部分:多个Socket、lO多路复用程序、文件事件分派器以及事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。<br>多个Socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器。然后一个Socket的事件处理完之后，IO多路复用程序才会将队列中的下一个Socket给事件分派器。文件事件分派器会根据每个Socket当前产生的事件，来选择对应的事件处理器来处理。</li>
<li>单线程快的原因:<br>1）纯内存操作<br>2）核心是基于非阻塞的IO多路复用机制<br>3）单线程反而避免了多线程的频繁上下文切换带来的性能问题</li>
</ul>
<h3 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h3><ul>
<li>缓存雪崩是指缓存同一时间大面积的失效 &#x2F; 缓存重启，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<ul>
<li>解决方案:<ul>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存（一直监控，消耗性能）</li>
<li>缓存预热（将热点数据加载到缓存后再启动服务）</li>
<li>互斥锁（缓存失效去查数据库时，锁住这个键，查完回来再解锁，防止大量请求）</li>
</ul>
</li>
</ul>
</li>
<li>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。<ul>
<li>解决方案:<ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;O的直接拦截（业务层逻辑，参数校验）;</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力（但bitmap中存在数据不一定存在）</li>
</ul>
</li>
</ul>
</li>
<li>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期)，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。<ul>
<li>解决方案<ul>
<li>设置热点数据永远不过期</li>
<li>加互斥锁（只让一个线程去查数据库，让其他线程CAS（自旋？），更新缓存）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事务实现——保证ACID"><a href="#事务实现——保证ACID" class="headerlink" title="事务实现——保证ACID"></a>事务实现——保证ACID</h3><ol>
<li><p><strong>事务开始</strong></p>
<ul>
<li>MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的flags属性中打开REDTS_MLTI标识来完成的。</li>
</ul>
</li>
<li><p><strong>命令入队</strong></p>
<ul>
<li><p>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回QUEUED回复</p>
<ul>
<li>如果客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器立即执行这个命令。</li>
<li>如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。首先检查此命令的格式（语法）是否正确：<ul>
<li>如果不正确，服务器会在客户端状态(redisclient)的flags属性关闭REDIS_MULTI标识，并且返回错误信息给客户端。</li>
<li>如果正确，将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复</li>
</ul>
</li>
</ul>
</li>
<li><p>事务队列是按照FIFO的方式保存入队的命令</p>
</li>
</ul>
</li>
<li><p><strong>事务执行</strong></p>
<ul>
<li><p>客户端发送EXEC命令，服务器执行EXEC命令逻辑。</p>
<ul>
<li>如果客户端状态的flags属性不包含REDIS_MULTI标识，或者包含REDIS_DIRTY_CAS或者REDIS_DIRTY_EXEC标识，那么就直接取消事务的执行。</li>
<li>否则客户端处于事务状态（flags有REDIS_MULTI标识)，服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端;</li>
</ul>
</li>
<li><p>Redis不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。</p>
</li>
<li><p>Redis事务不支持检查那些程序员自己逻辑错误（例如对 String类型的数据库键执行对HashMap类型的操作）</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>WATCH命令是一个乐观锁，可以为Redis事务提供check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
<li>MULTI命令用于<strong>开启一个事务</strong>，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值nil 。</li>
<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。 </li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h3 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h3><ul>
<li><p><strong>主从</strong>（互为主从）</p>
<ul>
<li><p>全量复制:</p>
<ol>
<li>主节点通过bgsave命令fork子进程进行RDB（全量数据快照文件）持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的</li>
</ol>
</li>
</ul>
<ol start="2">
<li>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</li>
<li>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令;如果从节点执行bgrewriteaof（AOF），也会带来额外的消耗</li>
</ol>
<ul>
<li>部分复制:<ol>
<li>复制偏移量：执行复制的双方，主从节点分别会维护一个复制偏移量offset（不一致以主为主）</li>
<li>复制积压缓冲区：主节点内部维护了一个固定长度的、先进先出(FIFO)队列作为复制积压缓冲区，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</li>
<li>服务器运行ID(runid)：每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：</li>
</ol>
<ul>
<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况);</li>
<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>哨兵模式</strong>（基于主从模式）——sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li><p>集群监控：负责监控redis master和slave进程是否正常工作。</p>
</li>
<li><p>消息通知：如果某个redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员</p>
</li>
<li><p>故障转移：如果master node挂掉了，会自动转移到slave node 上。</p>
</li>
<li><p>配置中心：如果故障转移发生了，通知client客户端新的master地址。</p>
</li>
</ul>
<blockquote>
<p>哨兵用于实现redis集群的高可用本身也是分布式的，作为一个哨兵集群去运行互相协同工作。</p>
</blockquote>
<ul>
<li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</li>
<li>哨兵通常需要3个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性。</li>
<li>对于哨兵+ redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
</li>
<li><p><strong>Redis Cluster</strong>是一种服务端Sharding（服务端分片——服务端决定key分配到哪个节点）技术，3.0版本开始正式提供。采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p>
<ul>
<li>方案说明<ul>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持强一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时需要需要把旧节点的数据迁移一部分到新节点</li>
<li>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另外一个就是加1w的端口号，比如16379。<blockquote>
<p>16379端口号是用来进行节点间通信的，也就是cluster bus的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
</blockquote>
</li>
</ul>
</li>
<li>优点<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
</li>
<li>缺点<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库（默认11个数据库）</li>
<li>不支持批量操作（pipeline管道操作）</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redis Sharding</strong>是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法（客户端分片——客户端决定key分配到哪个节点）。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java redis客户端驱动jedis，支持Redis Sharding功能，即Shardedjedis以及结合缓存池的ShardedJedisPool</p>
<ul>
<li>优点——优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强</li>
<li>缺点<ul>
<li>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战；</li>
<li>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整；</li>
<li>连接不能共享，当应用规模增大时，资源浪费制约优化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="CAP理论、BASE理论"><a href="#CAP理论、BASE理论" class="headerlink" title="CAP理论、BASE理论"></a>CAP理论、BASE理论</h2><ul>
<li>CAP理论<ul>
<li>consistency（一致性）：即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终—致。</li>
<li>Availability（可用性）：即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</li>
<li>Partition Tolerance（分区容错性）：即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</li>
<li>CP和AP：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能2选1</li>
</ul>
</li>
<li>BASE理论<ul>
<li>BASE是Basically Available (基本可用) 、Soft state(软状态)、Eventually consistent(最终一致性)</li>
<li>BASE理论是对CAP中<strong>一致性和可用性权衡的结果</strong>，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。</li>
<li>BASE理论的核心思想是:即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终—致性。</li>
<li>基本可用：<ul>
<li>响应时间上的损失:正常情况下，处理用户请求需要0.5s返回结果，但是由于系统出现故障，处理用户请求的时间变为3 s。</li>
<li>系统功能上的损失:正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
</li>
<li>软状态：数据同步允许一定的延迟</li>
<li>最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时</li>
</ul>
</li>
</ul>
<h2 id="负载均衡算法、类型"><a href="#负载均衡算法、类型" class="headerlink" title="负载均衡算法、类型"></a>负载均衡算法、类型</h2><h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h3><ul>
<li>轮询法：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li>
<li>随机法：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</li>
<li>源地址哈希法：源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li>
<li>加权轮询法：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li>
<li>加权随机法：与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</li>
<li>最小连接数法：最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理(快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>DNS（域名解析）方式实现负载均衡——效率高</li>
<li>硬件负载均衡：F5和A10</li>
<li>软件负载均衡：Nginx、HAproxy 、LVS<ul>
<li>其中的区别:<ul>
<li>Nginx：<ul>
<li>七层（应用层）负载均衡，支持 HTTP、E-mail 协议</li>
<li>同时也支持4层负载均衡</li>
<li>和客户端、服务端各有一个长连接——消耗资源、性能低</li>
<li>解析url，根据一定规则进行路由</li>
</ul>
</li>
<li>HAproxy（高可用代理器）：支持七层规则的，性能也很不错（OpenStack默认使用的负或均衡软件就是HAproxy）</li>
<li>LVS：运行在内核态，性能是软件负载均衡中最高的，在传输层负载均衡（替换指向LVS代理器的目标IP为代理的机器的IP,然后转发），严格来说工作在三层，所以更通用一些，适用各种应用服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何进行Session共享"><a href="#如何进行Session共享" class="headerlink" title="如何进行Session共享"></a>如何进行Session共享</h2><p>session（存在内存中）一般保存用户的登录态，单体应用下可以正常运行，但分布式情况下，经由负载均衡时可能在登陆时和使用其他服务时连接到了不同的服务器，导致session不同步，如何解决？</p>
<ul>
<li>采用无状态服务，抛弃session（使用JWT &#x2F; token）</li>
<li>存入cookie（有安全风险）（存在客户端——浏览器）</li>
<li>服务器之间进行Session同步，这样可以保证每个服务器上都有全部的Session信息，不过当服务器数量比较多的时候，占资源，同步是会有延迟甚至同步失败；</li>
<li>IP绑定策略：使用Nginx(或其他复杂均衡软硬件）中的IP绑定策略，同一个IP只能在指定的同一个机器访问，但是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大;</li>
<li>使用Redis存储：把Session放到Redis 中存储，虽然架构上变得复杂，并且需要多访问一次Redis，但是这种方案带来<br>的好处也是很大的：<ul>
<li>实现了Session共享;</li>
<li>可以水平扩展（增加Redis服务器);</li>
<li>服务器重启Session不丢失(不过也要注意Session在Redis 中的刷新&#x2F;失效机制)</li>
<li>不仅可以跨服务器Session共享，甚至可以跨平台（例如网页端和APP端) &#x2F; 跨语言。</li>
</ul>
</li>
</ul>
<h2 id="RPC、RMI（RPC的java实现版本）"><a href="#RPC、RMI（RPC的java实现版本）" class="headerlink" title="RPC、RMI（RPC的java实现版本）"></a>RPC、RMI（RPC的java实现版本）</h2><ul>
<li><p><strong>RPC</strong>：在本地调用远程的函数，远程过程调用，可以跨语言实现	httpClient</p>
</li>
<li><p><strong>RMI：</strong>远程方法调用，java中用于实现RPC的一种机制，RPC的java版本，是J2EE的网络调用机制，跨JVM调用对象的方法，面向对象的思维方式（调用与被调用都需要是java开发）</p>
<ul>
<li><p>直接或间接实现接口<strong>java.rmi.Remote</strong>，成为存在于服务器端的远程对象，供客户端访问并提供一定的服务</p>
</li>
<li><p>远程对象必须实现<strong>java.rmi.server.UnicastRemoteObject</strong>类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为”存根”，而服务器端本身已存在的远程对象则称之为”骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的之后调用远程方法来响应客户端的请求。</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public interface Iservice extends Remote{&#x2F;&#x2F;成为存在于服务器端的远程对象，供客户端访问并提供一定的服务<br>String service(string content) throws RemoteException;<br>}</p>
<p>public class ServiceImpl extends UnicastRemoteobject implements IService {&#x2F;&#x2F;远程对象将会把自身的一个拷贝以Socket的形式传输给客户端<br>private String name ;<br>public ServiceImpl(String name） throws RemoteException{<br>    this.name &#x3D; name;<br>}<br><br>@Override<br>public String Service(string content) {<br>    return “server &gt;&gt;” + content;<br>}<br>}<br>public class Server{ &#x2F;&#x2F;服务端<br>public static void main(string[]args){<br>    try{<br>        IService service02 &#x3D; new ServiceImpl( “service02”);<br>        Context namingcontext &#x3D; new Initia1context(); &#x2F;&#x2F;JVM提供的注册表机制(要手动启动)<br>        namingcontext.rebind(“rmi:&#x2F;&#x2F;127.0.0.1&#x2F;service02”，service02);<br>    }catch (Exception e){<br>        e.printstackTraceo;<br>    }<br>    System.out.print1n (“000000! “);<br>}<br>}<br>public class client{ &#x2F;&#x2F;客户端<br>public static void main(string[] args){<br>    String url &#x3D; “rmi :&#x2F;&#x2F;127.0.0.1&#x2F;“;<br>    try{<br>        context namingcontext &#x3D; new Initialcontext();<br>        Iservice service02 &#x3D; (Iservice) namingcontext.lookup(url + “service02”);&#x2F;&#x2F;从注册表找服务调用<br>        C1ass stubClass &#x3D; service02.getClass();<br>        System.out.print1n(service02 + “ is “ + stubc1ass.getName();<br>        &#x2F;&#x2F;com.sun. proxy . SProxyo<br>        Class [] interfaces &#x3D; stubc1ass.getInterfaces();<br>        for(Class c : interfaces){<br>            System.out.println(“imp1ement” + c.getName() + “ interface”);<br>        }<br>        System.out.println(serviceo2.service(“he11o”));<br>    }catch (Exception e){<br>        e .printstackTrace();<br>    }<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分布式id生成方案</span><br><span class="line"></span><br><span class="line">- UUID（本身唯一性）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>全局唯一如何保证？<br>    1.当前日期和时间	时间戳<br>    2.时钟序列	计数器<br>    3.全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。<br>优点：代码简单，性能好（本地生成，没有网络消耗），保证唯一（相对而言，重复概率极低可以忽略）<br>缺点：<br>    1.每次生成的ID都是无序的,而且不是全数字,且无法保证趋势递增。（对数据库聚簇索引不友好）<br>    2.UUID生成的是字符串，字符串存储性能差，查询效率慢，写的时候由于不能产生顺序的append操作，需要进行insert操作，导致频繁的页分裂，这种操作在记录占用空间比较大的情况下，性能下降比较大，还会增加读取磁盘次数<br>    3.UUID长度过长，不适用于存储，耗费数据库性能。<br>    4.ID无一定业务含义，可读性差。<br>    5.有信息安全问题，有可能泄露mac地址（有机器识别号）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 数据库自增序列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>单机模式:<br>    优点:<br>        1.实现简单，依靠数据库即可，成本小。<br>        2.ID数字化，单调自增,满足数据库存储和查询性能。<br>        3.具有一定的业务可读性。（结合业务code）<br>    缺点:<br>        1.强依赖DB，存在单点问题,如果数据库宕机,则业务不可用。<br>        2.DB生成ID性能有限,单点数据库压力大,无法扛高并发场景。<br>        3.信息安全问题，比如暴露订单量，url查询改一下id查到别人的订单</p>
<p>数据库高可用:多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于节点数<br>    优点:解决了ID生成的单点问题,同时平衡了负载。<br>    缺点:<br>        1.系统扩容困难:系统定义好步长之后，增加机器之后调整步长困难。<br>        2.数据库压力大:每次获取一个ID都必须读写一次数据库。<br>        3.主从同步的时候:电商下单-&gt;支付insert master db select数据﹐因为数据同步延迟导致查不到这个数据。加cache（不是最好的解决方式）数据要求比较严谨的话查master主库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Leaf-segment</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一、采用每次获取一个ID区间段的方式来解决，区间段用完之后再去数据库获取新的号段，这样一来可以大大减轻数据库的压力<br>核心字段:biz_tag，max_id, step<br>    biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度，原来每次获取ID都要访问数据库，现在只需要把Step设置的足够合理如1000，那么现在可以在1000个ID用完之后再去访问数据库<br>优点:<br>    1.扩张灵活，性能强能够撑起大部分业务场景。<br>    2.ID号码是趋势递增的,满足数据库存储和查询性能要求。<br>    3.可用性高，即使ID生成服务器不可用，也能够使得业务在短时间内可用，为排查问题争取时间。<br>缺点:可能存在多个节点同时请求ID区间的情况，依赖DB</p>
<p>二、双buffer（优化）:将获取一个号段的方式优化成获取两个号段，在一个号段用完之后不用立马去更新号段，还有一个缓存号段备用，这样能够有效解决这种冲突问题，而且采用双buffer的方式，在当前号段消耗了10%的时候就去检查下一个号段有没有准备好，如果没有准备好就去更新下一个号段，当前号段用完了就切换到下一个已经缓存好的号段去使用，同时在下一个号段消耗到10%的时候，又去检测下一个号段有没有准备好，如此往复。</p>
<p>优点:基于VM存储双buffer的号段，减少了数据库查询，减少了（对数据库的）网络依赖，效率更高。<br>缺点:<br>    1.segment号段长度是固定的，业务量大时可能会频繁更新号段，因为原本分配的号段会一下用完<br>    2.如果号段长度设置的过长，但凡缓存中有号段没有消耗完，其他节点重新获取的号段与之前相比可能跨度会很大，动态调整Step</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 基于redis（比mysql吞吐量更大，并发）、mongoDB、zk等中间件生成</span><br><span class="line"></span><br><span class="line">- 雪花算法（best）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成一个64bit的整性数字<br>第一位符号位固定为0，41位时间戳，10位workId（机器号，给分布式集群中每个机器定的id），12位序列号<br>（位数可以有不同实现）</p>
<p>优点:<br>    1.每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。<br>    2.时间戳值在高位，中间是固定的机器码，白增的序列在低位，整个ID是趋势递增的。<br>    3.能够根据业务场景数据库节点布置灵活挑战bit位划分，灵活度高。<br>缺点:强依赖于机器时钟，如果时钟回拨（自己设置系统时间），会导致重复的ID生成，所以一般基于此的算法发现时钟回拨，都会抛异常处理,阻止ID生成，这可能导致服务不可用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分布式锁</span><br><span class="line"></span><br><span class="line">需要这个锁独立于每一个服务之外，而不是在服务里面。</span><br><span class="line"></span><br><span class="line">- 数据库：利用主键冲突控制一次只有一个线程能获取锁，</span><br><span class="line">  - 非阻塞、不可重入（递归时）、单点、失效时间</span><br><span class="line">- Zookeeper分布式锁：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>zk通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应（结束线程后，唤醒阻塞队列中哪个线程）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **Redis分布式锁**：setNX命令，单线程处理网络请求，不需要考虑并发安全性</span><br><span class="line"></span><br><span class="line">  所有服务节点设置相同的key，返回为0、则锁获取失败</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>setnx<br>问题:<br>    1、早期版本没有超时参数，需要单独设置，存在死锁问题（中途宕机&gt;<br>    2、后期版本提供加锁与设置时间原子操作，但是存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题（可以在value中放一个自动生成的uuid，和锁比较过后一致则删除）<br>        2.1、删除锁：判断线程唯一标志，再删除<br>可重入性及锁续期（任务未完成，过期时间到释放锁）没有实现，通过redisson解决（类似AQS的实现，看门狗监听机制（判断是否执行完成，未完成重设key的过期时间）</p>
<p>&#96;&#96;&#96;</p>
<ul>
<li>redlock：意思的机制都只操作单节点、即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发牛了主从切换，那么就会出现锁丢失的情况。（redis同步设置可能数据丢失）——redlock从多个节点申请锁，当一半以上节点获取成功、锁才算获取成功，redission有相应的实现</li>
</ul>
<h2 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h2><ul>
<li><p>场景：一个方法里面操作两个数据源 &amp; 两个不同的节点上的两个数据源</p>
</li>
<li><p>问题：两个数据源共同的提交、共同回滚、保证事务原子性</p>
</li>
<li><p>解决方案：</p>
<ul>
<li><p>XA规范：分布式事务规范。定义了分布式事务模型</p>
<ul>
<li><p>四个角色：事务管理器(协调者TM)、资源管理器(参与者RM)、应用程序AP、通信资源管理器CRM</p>
</li>
<li><p>全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚</p>
</li>
<li><p>JTA事务：java对XA规范的实现，对应JDBC的单库事务</p>
</li>
<li><p>具体实现：</p>
<ul>
<li><p>两阶段协议：</p>
<ul>
<li>①第一阶段（ prepare ) ：发送prepare消息（基本完成sql语句操作），但未提交事务；每个参与者执行本地事务但不提交，进入ready状态，并通知协调者已经准备就绪。</li>
<li>②第二阶段（commit）：当协调者确认每个参与者都ready后，通知参与者进行commit 操作；如果有参与者fail则发送rollback命令，各参与者做回滚。如果阶段一所有prepare操作成功 &#x2F; 失败，则通知所有库提交事务 &#x2F; 回滚事务</li>
</ul>
</li>
<li><p>两阶段协议问题：</p>
<ul>
<li>单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）</li>
<li>数据不一致：在阶段二，如果事务管理器只发送了部分commit消息，此时网络发生异常，那么只有部分参与者接收到commit消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li>响应时间较长：参与者和协调者资源都被锁住，提交或者回滚之后才能释放</li>
<li>不确定性：当协事务管理器发送commit之后，并且此时只有一个参与者收到了commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li>
</ul>
</li>
<li><p>三阶段协议：主要是针对两阶段的优化，解决了单点故障的问题，但是性能问题&amp;不一致问题仍没有根本解决（引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc只有协调者有超时机制）</p>
<ul>
<li>阶段一：TM发送CanCommit消息，确认数据库环境正常：协调者询问事务参与者，是否有能力完成此次事务。<ul>
<li>如果都返回yes，则进入第二阶段</li>
<li>有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求</li>
</ul>
</li>
<li>阶段二：发送PreCommit消息，此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作。参与者执行完事务操作后（此时属于未提交事务的状态)，就会向协调者反馈”Ack”表示我已经准备好提交了，并等待协调者的下一步指令。</li>
<li>阶段三：发送DoCommit消息，通知所有库提交 &#x2F; 回滚事务。在阶段二中如果所有的参与者节点都返回了Ack，那么协调者就会从”预提交状态”转变为”提交状态”。然后向所有的参与者节点发送”doCommit”请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈”Ack”消息，协调者收到所有参与者的Ack消息后完成事务。相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。</li>
</ul>
</li>
<li><p>TCC(补偿事务)：Try、Confirm（commit）、Cancel（业务层面上的rollback）</p>
<ul>
<li>针对每个操作，都要注册一个与其对应的确认和补偿(撤销)操作</li>
<li>Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作既回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm &#x2F; Cancel操作若执行失败，TM会进行重试。</li>
<li>TCC模型对<strong>业务的侵入性较强，改造的难度较大</strong>，每个操作都需要有try、confirm、cancel三个接口实现</li>
<li>confirm和cancel接口还必须实现幂等性。</li>
</ul>
</li>
<li><p>消息队列的事务消息</p>
<ul>
<li>发送prepare消息到消息中间件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>发送成功后，执行本地事务</p>
<ul>
<li><p>如果事务执行成功，则commit，消息中间件将消息下发至消费端(commit前，消息不会被消费)。</p>
</li>
<li><p>如果事务执行失败。则回滚，消息中间件将这条prepare消息删除<br>- 消费端接收到消息进行消费。如果消费失败，则不断重试</p>
</li>
</ul>
</li>
</ul>
<h2 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h2><p>高并发场景下，相同的参数重复点击时保证数据正确</p>
<ul>
<li>唯—id：每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在则执行后续操作，并且保存到数据库或者redis等。</li>
<li>服务端提供发送token的接口，业务调用接口前先获取token，然后调用业务接口请求时，把token携带过去，服务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除</li>
<li>建去重表：将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了</li>
<li>版本控制：增加版本号，当版本号符合时，才能更新数据（类似乐观锁）</li>
<li>状态控制：例如订单有状态已支付、未支付、支付中、支付失败，前置后续条件，当处于未支付的时候才允许修改为支付中等</li>
</ul>
<h1 id="Zookeeper——分布式协调服务"><a href="#Zookeeper——分布式协调服务" class="headerlink" title="Zookeeper——分布式协调服务"></a>Zookeeper——分布式协调服务</h1><h2 id="ZAB协议（zk专用）"><a href="#ZAB协议（zk专用）" class="headerlink" title="ZAB协议（zk专用）"></a>ZAB协议（zk专用）</h2><ul>
<li><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，实现分布式数据一致性（CAP理论中的C——强一致性）（选择了CP）</p>
</li>
<li><p>所有客户端的请求都是写入到Leader进程中，然后由Leader同步到其他节点，称为Follower（主从）。在集群数据同步的过程中，如果出现 Follower节点崩溃或者Leader进程崩溃时，都会通过ZAB协议来保证数据一致性</p>
</li>
<li><p>ZAB协议包括两种基本的模式：<strong>崩溃恢复</strong>和<strong>消息广播</strong></p>
<ul>
<li>消息广播:<ul>
<li>集群中所有的事务请求都由Leader节点来处理，其他服务器为Follower，Leader将客户端的事务请求转换为事务Proposal，并且将Proposal 分发给集群中其他所有的Follower。</li>
<li>完成广播之后，Leader等待Follwer反馈，当有过半数的Follower反馈信息后，Leader将再次向集群内Follower广播Commit信息，Commit信息就是确认将之前的 Proposal提交。</li>
<li>Leader节点的写入是一个两步操作，第一步是广播事务操作，第二步是广播提交操作，其中过半数指的是反馈的节点数&gt;&#x3D;N&#x2F;2+1，N是全部的Follower节点数量。</li>
</ul>
</li>
<li>崩溃恢复：（此时不可用）<ol>
<li>初始化集群，刚刚启动的时候</li>
<li>Leader崩溃，因为故障宕机</li>
<li>Leader 失去了半数的机器支持，与集群中超过一半的节点断连</li>
</ol>
<ul>
<li>此时开启新一轮Leader选举，选举产生的Leader会与过半的Follower进行同步，使数据一致，当与过半的机器同步完成后，就退出恢复模式，然后进入消息广播模式</li>
</ul>
</li>
</ul>
</li>
<li><p>整个ZooKeeper集群的一致性保证就是在上面两个状态之前切换，当Leader服务正常时，就是正常的消<strong>息广播模式</strong>；当Leader不可用时，则进入<strong>崩溃恢复模式</strong>，崩溃恢复阶段会进行数据同步，完成以后，重新进入消息广播阶段。</p>
</li>
<li><p><strong>Zxid</strong>：Zab协议的一个事务编号，Zxid是一个64位的数字，其中低32位是一个简单的单调递增计数器，针对客户端每一个事务请求，计数器加1;而高32位则代表Leader周期年代的编号。</p>
</li>
<li><p>Leader周期( epoch），可以理解为当前集群所处的年代或者周期，每当有一个新的Leader选举出现时，就会从这个Leader服务器上取出其本地日志中最大事务的Zxid，并从中读取epoch值，然后加1，以此作为新的周期ID。高32位代表了每代Leader的唯一性，低32位则代表了每代Leader中事务的唯一性。</p>
</li>
<li><p>zab节点的三种状态：</p>
<ul>
<li>following：服从leader的命令</li>
<li>leading：负责协调事务</li>
<li>election&#x2F;looking：选举状态（崩溃恢复阶段）</li>
</ul>
</li>
</ul>
<h2 id="zk的数据模型和节点类型"><a href="#zk的数据模型和节点类型" class="headerlink" title="zk的数据模型和节点类型"></a>zk的数据模型和节点类型</h2><ul>
<li><strong>数据模型</strong>——树形结构<ul>
<li>zk维护的数据主要有：客户端的会话（session）状态及数据节点（dataNode）信息。</li>
<li>zk在内存中构造了个DataTree的数据结构，维护着path到dataNode的映射以及dataNode间的树状层级关系。为了提高读取性能，集群中每个服务节点都是将数据全量存储在内存中。所以zk最适于<strong>读多写少且轻量级数据的应用场景</strong>。</li>
<li>数据仅存储在内存是很不安全的，zk采用事务日志文件及快照文件的方案来落盘数据，保障数据在不丢失的情况下能快速恢复。</li>
<li>树中的每个节点被称为一Znode</li>
<li>Znode兼具文件和目录两种特点。可以做路径标识，也可以存储数据，并可以具有子Znode。具有增、删、改、查等操作。</li>
<li>Znode具有原子性操作，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的 ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作</li>
<li>Znode存储数据大小有限制。每个Znode的数据大小至多1M，常规使用中应该远小于此值。</li>
<li>Znode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示（没有相对路径），因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串”&#x2F;zookeeper”用以保存管理信息，比如关键配额信息。</li>
</ul>
</li>
<li><strong>节点类型</strong>：<ul>
<li>持久节点：一旦创建、该数据节点会一直存储在zk服务器上、即使创建该节点的客户端与服务端的会话关闭了该节点也不会被删除</li>
<li>临时节点：当创建该节点的客户端会话因超时或发生异常而关闭时、该节点也相应的在zk上被删除。</li>
<li>有序节点：不是一种单独种类的节点、而是在持久节点和临时节点的基础上、增加了一个节点有序的性质</li>
</ul>
</li>
</ul>
<h2 id="zk的命名服务、配置管理、集群管理——三种使用场景"><a href="#zk的命名服务、配置管理、集群管理——三种使用场景" class="headerlink" title="zk的命名服务、配置管理、集群管理——三种使用场景"></a>zk的命名服务、配置管理、集群管理——三种使用场景</h2><ul>
<li>命名服务：通过指定的名字来获取资源或者服务地址。Zookeeper可以创建一个全局唯一的路径，这个路径就可以作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服务框架(RPC、RMI)中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取资源的实体、服务地址和提供者信息等</li>
<li>配置管理：实际项目开发中，经常使用.properties或者xml需要配置很多信息，如数据库连接信息、fps地址端口等等。程序分布式部署时，如果把程序的这些配置信息保存在zk的znode节点下，当你要修改配置，即znode会发生变化时，可以通过改变k中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。<ul>
<li><strong>watch机制</strong>（监听机制）——客户端可以通过在znode上设置watch，实现实时监听znode的变化<ul>
<li>Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端<ul>
<li>父节点的创建，修改，部除都会触发Watcher事件。</li>
<li>子节点的创建，册除会触发Watcher事件。</li>
</ul>
</li>
<li>一次性：一旦被触发就会移除，再次使用需要重新注册，因为每次变动都需要通知所有客户端，一次性可以减轻压力，3.6.0默认持久递归，可以触发多次</li>
<li>轻量：只通知发生了事件，不会告知事件内容，减轻服务器和带宽压力</li>
<li>Watcher机制包括三个角色：客户端线程、客户端的 WatchManager、ZooKeeper服务器<ol>
<li>客户端向ZooKeeper 服务器注册一个Watcher监听</li>
<li>把这个监听信息存储到客户端的WatchManager中</li>
<li>当ZooKeeper 中的节点发生变化时，会通知客户端，客户端会调用相应Watcher对象中的回调方法（watch回调是串行同步的）</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>集群管理：集群管理包括集群监控和集群控制，就是监控集群机器状态，剔除机器和加入机器。zookeeper可以方便集群机器的管理，它可以实时监控znode节点的变化，一旦发现有机器挂了，该机器就会与zk断开连接，对应的临时目录节点会被删除，其他所有机器都收到通知，新机器加入也是类似。</li>
</ul>
<h2 id="zk与eureka的区别（CAP理论）"><a href="#zk与eureka的区别（CAP理论）" class="headerlink" title="zk与eureka的区别（CAP理论）"></a>zk与eureka的区别（CAP理论）</h2><ul>
<li>zk：CP设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。<ul>
<li>当节点crash后，需要进行leader的选举，在这个期间内，zk服务是不可用的。</li>
</ul>
</li>
<li>eureka：AP设计(高可用)，目标是一个服务注册发现系统，专门用于微服务的服务发现注册。<ul>
<li>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)</li>
<li>同时当eureka的服务端发现85%以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会从服务列表中删除这些失去心跳的服务，同时eureka的客户端也会缓存服务信息。eureka对于服务注册发现来说是非常好的选择。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">LLoyyj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">http://lloyyj.github.io/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1/">八股</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/14/Java%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Java基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/13/MySQL%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"><img class="next-cover" src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MySQL学习日记（三）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/01/14/Java基础——集合/" title="Java基础——集合"><img class="cover" src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-14</div><div class="title">Java基础——集合</div></div></a></div><div><a href="/2023/01/18/算法题解题思路/" title="算法题解题思路"><img class="cover" src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-18</div><div class="title">算法题解题思路</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://s2.loli.net/2023/01/11/1NsbGvmfukWXBQM.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">LLoyyj</div><div class="author-info__description">属于我人生的一小步</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LLoyyJ"><i class="fab fa-github"></i><span>关注我一下下？</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">你自己偷偷知道就好啦 ~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SSM"><span class="toc-number">1.</span> <span class="toc-text">SSM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">1.1.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">Spring是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E3%80%81OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">AOP面向切面、OOP面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC"><span class="toc-number">1.1.3.</span> <span class="toc-text">IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory%E5%92%8CApplicationContext"><span class="toc-number">1.1.4.</span> <span class="toc-text">BeanFactory和ApplicationContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">Spring Bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.6.</span> <span class="toc-text">Spring框架中用到了那些设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-x2F-%E5%8E%9F%E7%90%86-x2F-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.1.7.</span> <span class="toc-text">Spring事务的实现方式 &#x2F; 原理 &#x2F; 隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.8.</span> <span class="toc-text">spring事务传播机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88-%E2%80%94%E2%80%94-%E5%8E%9F%E7%90%86%E6%98%AFAOP%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%88%87%E9%9D%A2%E5%A2%9E%E5%BC%BA%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E6%98%AFAOP%E5%A4%B1%E6%95%88"><span class="toc-number">1.1.9.</span> <span class="toc-text">Spring事务失效 —— 原理是AOP进行了切面增强，事务失效原因是AOP失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">1.1.10.</span> <span class="toc-text">bean的自动装配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot"><span class="toc-number">1.2.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E3%80%81SpringMVC%E3%80%81Spring"><span class="toc-number">1.2.1.</span> <span class="toc-text">SpringBoot、SpringMVC、Spring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis"><span class="toc-number">1.3.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis-%E5%92%8C-Hibernate"><span class="toc-number">1.3.1.</span> <span class="toc-text">Mybatis 和 Hibernate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">#{} 和${}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">Mybatis插件运行原理，如何编写一个插件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">2.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9AMyISAM-amp-InnoDB"><span class="toc-number">2.0.1.</span> <span class="toc-text">存储引擎：MyISAM&amp;InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">2.0.2.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%94%81%EF%BC%88%E5%8F%AF%E4%BB%A5%E6%98%BE%E5%BC%8F%E5%8A%A0%E9%94%81-x2F-%E8%87%AA%E5%8A%A8%E5%8A%A0%E9%94%81%EF%BC%89"><span class="toc-number">2.0.3.</span> <span class="toc-text">MySQL锁（可以显式加锁 &#x2F; 自动加锁）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">2.0.4.</span> <span class="toc-text">MySQL执行计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7-amp-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">2.0.5.</span> <span class="toc-text">事务的基本特性&amp;隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%80%97%E6%97%B6%E2%80%94%E2%80%94%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">2.0.6.</span> <span class="toc-text">SQL耗时——慢查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.7.</span> <span class="toc-text">主从同步原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%EF%BC%88%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">Redis（单进程单线程）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-amp-AOF%E6%9C%BA%E5%88%B6"><span class="toc-number">3.0.1.</span> <span class="toc-text">RDB &amp; AOF机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.0.2.</span> <span class="toc-text">过期键的删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.0.3.</span> <span class="toc-text">线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.0.4.</span> <span class="toc-text">缓存雪崩、缓存穿透、缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E4%BF%9D%E8%AF%81ACID"><span class="toc-number">3.0.5.</span> <span class="toc-text">事务实现——保证ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">3.0.6.</span> <span class="toc-text">Redis集群方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA%E3%80%81BASE%E7%90%86%E8%AE%BA"><span class="toc-number">4.1.</span> <span class="toc-text">CAP理论、BASE理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">负载均衡算法、类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">算法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CSession%E5%85%B1%E4%BA%AB"><span class="toc-number">4.3.</span> <span class="toc-text">如何进行Session共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E3%80%81RMI%EF%BC%88RPC%E7%9A%84java%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">RPC、RMI（RPC的java实现版本）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.5.</span> <span class="toc-text">分布式事务解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">4.6.</span> <span class="toc-text">接口的幂等性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Zookeeper%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">Zookeeper——分布式协调服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ZAB%E5%8D%8F%E8%AE%AE%EF%BC%88zk%E4%B8%93%E7%94%A8%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">ZAB协议（zk专用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zk%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">zk的数据模型和节点类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zk%E7%9A%84%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1%E3%80%81%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E3%80%81%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94%E4%B8%89%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.3.</span> <span class="toc-text">zk的命名服务、配置管理、集群管理——三种使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zk%E4%B8%8Eeureka%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88CAP%E7%90%86%E8%AE%BA%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">zk与eureka的区别（CAP理论）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/18/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/" title="算法题解题思路"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法题解题思路"/></a><div class="content"><a class="title" href="/2023/01/18/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/" title="算法题解题思路">算法题解题思路</a><time datetime="2023-01-18T08:43:39.000Z" title="Created 2023-01-18 16:43:39">2023-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/14/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/" title="Java基础——集合"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础——集合"/></a><div class="content"><a class="title" href="/2023/01/14/Java%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/" title="Java基础——集合">Java基础——集合</a><time datetime="2023-01-14T12:25:14.000Z" title="Created 2023-01-14 20:25:14">2023-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/14/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2023/01/14/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2023-01-14T11:31:14.000Z" title="Created 2023-01-14 19:31:14">2023-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" title="面试八股"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试八股"/></a><div class="content"><a class="title" href="/2023/01/14/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" title="面试八股">面试八股</a><time datetime="2023-01-14T07:27:59.000Z" title="Created 2023-01-14 15:27:59">2023-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/13/MySQL%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" title="MySQL学习日记（三）"><img src="https://s2.loli.net/2023/01/11/IgN6lKQZ2kBHbev.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL学习日记（三）"/></a><div class="content"><a class="title" href="/2023/01/13/MySQL%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" title="MySQL学习日记（三）">MySQL学习日记（三）</a><time datetime="2023-01-13T03:27:49.000Z" title="Created 2023-01-13 11:27:49">2023-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> LLoyyj</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">开心就好<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7427714271" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script data-pjax defer src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>